#!/usr/bin/python
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Play command line script www.playframework.org/

import sys
import os
import os.path
import string
import shutil
import fileinput
import random
import re
import subprocess
import time
import webbrowser
import urllib
import urllib2
import socket
import getopt
import zipfile
import imp
import tempfile

# ~~~~~~~~~
# Utilities

toKill = None
modules_server = 'http://www.playframework.org'

def replaceAll(file, searchExp, replaceExp):
	replaceExp = replaceExp.replace('\\', '\\\\')
	searchExp = searchExp.replace('$', '\\$')
	searchExp = searchExp.replace('{', '\\{')
	searchExp = searchExp.replace('}', '\\}')
	searchExp = searchExp.replace('.', '\\.')
	for line in fileinput.input(file, inplace=1):
		line = re.sub(searchExp, replaceExp, line)
		sys.stdout.write(line)

def secretKey():
	return ''.join([random.choice('abcdefghijklmnopqrstuvwxyz0123456789') for i in range(64)])

def readConf(key):
	if application_path:
		keyRe = re.compile('^%' + play_id + '.' + key + '\s*=')
		for line in open(os.path.join(application_path, 'conf/application.conf')).readlines():
			if keyRe.match(line):
				return line[line.find('=')+1:].strip()
		keyRe = re.compile('^' + key + '\s*=')
		for line in open(os.path.join(application_path, 'conf/application.conf')).readlines():
			if keyRe.match(line):
				return line[line.find('=')+1:].strip()
	return ''

def readConfs(key):
	result = []
	if application_path:
		for line in open(os.path.join(application_path, 'conf/application.conf')).readlines():
			if line.startswith(key):
				result.append(line[line.find('=')+1:].strip())
		for line in open(os.path.join(application_path, 'conf/application.conf')).readlines():
			if line.startswith('%' + play_id + '.' + key):
				result.append(line[line.find('=')+1:].strip())
	return result

def isParentOf(path1, path2):
	if len(path2) < len(path1) or len(path2) < 2:
		return False
	if (path1 == path2):
		return True
	return isParentOf(path1, os.path.dirname(path2))

def kill(pid):
	if os.name == 'nt':
		import ctypes
		handle = ctypes.windll.kernel32.OpenProcess(1, False, int(pid))
		if not ctypes.windll.kernel32.TerminateProcess(handle, 0):
			print "~ Cannot kill the process with pid %s (ERROR %s)" % (pid, ctypes.windll.kernel32.GetLastError())
			print "~ "
			sys.exit(-1)
	else:
		try:
			os.kill(int(pid), 15)
		except OSError:
			print "~ Play was not running (Process id %s not found)" % pid
			print "~"
			sys.exit(-1)

def override(f, t):
	fromFile = None
	for module in modules:
		pc = os.path.join(module, f)
		if os.path.exists(pc): fromFile = pc
	if not fromFile:
		print "~ %s not found in any modules" % f
		print "~ "
		sys.exit(-1)
	toFile = os.path.join(application_path, t)
	if os.path.exists(toFile):
		response = raw_input("~ Warning! %s already exists and will be overriden (y/n)? " % toFile)
		if not response == 'y':
			return
	if not os.path.exists(os.path.dirname(toFile)):
		os.makedirs(os.path.dirname(toFile))
	shutil.copyfile(fromFile, toFile)
	print "~ Copied %s to %s " % (fromFile, toFile)

def load_module_list():
	try:
		url = '%s/modules' % modules_server
		proxy_handler = urllib2.ProxyHandler({})
		req = urllib2.Request(url)
		req.add_header('Accept', 'application/json')
		opener = urllib2.build_opener(proxy_handler)
		result = opener.open(req)
		return json.loads(result.read())
	except urllib2.HTTPError, e:
		print "~ Oops,"
		print "~ Cannot fetch the modules list from %s (%s)..." % (url, e.code)
		print "~"
		sys.exit(-1)
	except urllib2.URLError, e:
		print "~ Oops,"
		print "~ Cannot fetch the modules list from %s ..." % (url)
		print "~"
		sys.exit(-1)

class Downloader(object):
	before = .0
	history = []
	cycles = 0
	average = lambda self: sum(self.history) / (len(self.history) or 1)

	def __init__(self, width=55):
		self.width = width
		self.kibi = lambda bits: bits / 2 ** 10
		self.proc = lambda a, b: a / (b * 0.01)

	def retrieve(self, url, destination, callback=None):
		self.size = 0
		time.clock()
		try: urllib.urlretrieve(url, destination, self.progress)
		except KeyboardInterrupt:
			print '\n~ Download cancelled'
			print '~'
			for i in range(5):
				try:
					os.remove(destination)
					break
				except:
					time.sleep(.1)
			else: raise
			if callback: callback()
			sys.exit()
		print ''
		return self.size

	def progress(self, blocks, blocksize, filesize):
		self.cycles += 1
		bits = min(blocks*blocksize, filesize)
		done = self.proc(bits, filesize) if bits != filesize else 100
		bar = self.bar(done)
		if not self.cycles % 3 and bits != filesize:
			now = time.clock()
			elapsed = now-self.before
			if elapsed:
				speed = self.kibi(blocksize * 3 / elapsed)
				self.history.append(speed)
				self.history = self.history[-4:]
			self.before = now
		average = round(sum(self.history[-4:]) / 4, 1)
		self.size = self.kibi(bits)
		print '\r~ [%s] %s KiB/s  ' % (bar, str(average)),

	def bar(self, done):
		span = self.width * done * 0.01
		offset = len(str(int(done))) - .99
		result = ('%d%%' % (done,)).center(self.width)
		return result.replace(' ', '-', int(span - offset))

class Unzip:
	def __init__(self, verbose = False, percent = 10):
		self.verbose = verbose
		self.percent = percent

	def extract(self, file, dir):
		if not dir.endswith(':') and not os.path.exists(dir):
			os.mkdir(dir)
		zf = zipfile.ZipFile(file)
		# create directory structure to house files
		self._createstructure(file, dir)
		num_files = len(zf.namelist())
		percent = self.percent
		divisions = 100 / percent
		perc = int(num_files / divisions)
        # extract files to directory structure
		for i, name in enumerate(zf.namelist()):
			if self.verbose == True:
				print "Extracting %s" % name
			elif perc > 0 and (i % perc) == 0 and i > 0:
				complete = int (i / perc) * percent
			if not name.endswith('/'):
				outfile = open(os.path.join(dir, name), 'wb')
				outfile.write(zf.read(name))
				outfile.flush()
				outfile.close()


	def _createstructure(self, file, dir):
		self._makedirs(self._listdirs(file), dir)

	def _makedirs(self, directories, basedir):
		""" Create any directories that don't currently exist """
		for dir in directories:
			curdir = os.path.join(basedir, dir)
			if not os.path.exists(curdir):
				os.makedirs(curdir)

	def _listdirs(self, file):
		""" Grabs all the directories in the zip structure
		This is necessary to create the structure before trying
		to extract the file to it. """
		zf = zipfile.ZipFile(file)
		dirs = []
		for name in zf.namelist():
			dn = os.path.dirname(name)
			dirs.append(dn)
		dirs.sort()
		return dirs

def isParentOf(path1, path2):
	if len(path2) < len(path1) or len(path2) < 2:
		return False
	if (path1 == path2):
		return True

# ~~~~~~~~~~
# Dynamically load more modules

def load_module(name):
	base = os.path.normpath(os.path.dirname(os.path.realpath(sys.argv[0])))
	mod_desc = imp.find_module(name, [os.path.join(base, 'framework/pym')])
	return imp.load_module(name, mod_desc[0], mod_desc[1], mod_desc[2])

json = load_module('simplejson')

# ~~~~~~~~~
# Main

try:
	
	# ~~~~~~~~~~~~~~~~~~~~~~ Where is the framework?
	play_base = os.path.normpath(os.path.dirname(os.path.realpath(sys.argv[0])))

	
	# ~~~~~~~~~~~~~~~~~~~~~~ What is the framework id?
	id_file = os.path.join(play_base, 'id')
	if os.path.exists(id_file):
		play_id = open(id_file).readline().strip()
	else:
		play_id = ''

	
	# ~~~~~~~~~~~~~~~~~~~~~~ Display logo
	print r"~        _            _ "
	print r"~  _ __ | | __ _ _  _| |"
	print r"~ | '_ \| |/ _' | || |_|"
	print r"~ |  __/|_|\____|\__ (_)"
	print r"~ |_|            |__/   "
	print r"~"
	
	play_version_file = os.path.join(play_base, 'framework/src/play/version')
	if not os.path.exists(play_version_file):
		print "~ Oops. %s file not found" % os.path.normpath(os.path.join(play_base, 'framework/src/play/version'))
		print "~ Is the framework compiled? "
		print "~"
		sys.exit(-1)
	
	play_version = open(play_version_file).readline().strip()
	
	print "~ play! %s, http://www.playframework.org" % (play_version)
	
	# ~~~~~~~~~~~~~~~~~~~~~~ Where is the application?
	application_path = None
	remaining_args = []
	if len(sys.argv) == 2:
		application_path = os.getcwd()
		remaining_args = sys.argv[2:]
	if len(sys.argv) > 2:
		if sys.argv[2].startswith('-'):
			application_path = os.getcwd()
			remaining_args = sys.argv[2:]
		else:
			application_path = os.path.normpath(os.path.abspath(sys.argv[2]))
			remaining_args = sys.argv[3:]

	
	# ~~~~~~~~~~~~~~~~~~~~~~ What is the command?
	if len(sys.argv) > 1:
		play_command = sys.argv[1]
	else:
		play_command = 'none'
			
	
	# ~~~~~~~~~~~~~~~~~ Override id
	for a in remaining_args:
		if a.find('--%') == 0:
			play_id = a[3:]
	
	if play_command == 'test' or play_command == 'auto-test':
		play_id = 'test'

	
	if play_id:
		print "~ framework ID is %s" % play_id
	print "~"
	
	# ~~~~~~~~~~~~~~~~~~~~~~ Check if it's a valid application
	def check_application():
		global http_port
		if application_path and not os.path.exists(os.path.join(application_path, 'conf/routes')):
			print "~ Oops. %s does not seem to host a valid application" % os.path.normpath(application_path)
			print "~"
			sys.exit(-1)
		http_port = readConf('http.port')
		if not http_port:
			http_port = '9000'

	
	# ~~~~~~~~~~~~~~~~~~~~~~ Modules list
	def load_modules():
		global modules
		if os.environ.has_key('MODULES'):
			if os.name == 'nt':
				modules = os.environ['MODULES'].split(';')
			else:
				modules = os.environ['MODULES'].split(':')
		else:
			modules = []
		pm = readConfs('module.')
		for m in pm:
			om = m
			if '${play.path}' in m:
				m = m.replace('${play.path}', play_base)
			if not m[0] == '/':
				m = os.path.normpath(os.path.join(application_path, m))

			if not os.path.exists(m):
				print "~ Oops,"
				print "~ Module not found: %s" % (m)
				print "~"

				if om.startswith('${play.path}/modules'):
					print "~ You can try to install the missing module using 'play install %s'" % (om[21:])
					print "~"
				sys.exit(0)
				
			modules.append(m)
		if play_id == 'test':
			modules.append(os.path.normpath(os.path.join(play_base, 'modules/test-runner')))


	# ~~~~~~~~~~~~~~~~~~~~~~ Build classpath
	def do_classpath():
		global classpath
		global cp_args
		global agent_path
		
		agent_path=os.path.join(play_base, 'framework/play.jar')
		
		classpath = []
		
		# The default
		classpath.append(os.path.normpath(os.path.join(application_path, 'conf')))
		classpath.append(os.path.normpath(os.path.join(play_base, 'framework/play.jar')))
		
		# The application
		if os.path.exists(os.path.join(application_path, 'lib')):
			for jar in os.listdir(os.path.join(application_path, 'lib')):
				if jar.endswith('.jar'):
					classpath.append(os.path.normpath(os.path.join(application_path, 'lib/%s' % jar)))
		
		# The modules
		for module in modules:
			if os.path.exists(os.path.join(module, 'lib')):
				libs = os.path.join(module, 'lib')
				if os.path.exists(libs):
					for jar in os.listdir(libs):
						if jar.endswith('.jar'):
							classpath.append(os.path.normpath(os.path.join(libs, '%s' % jar)))
		
		# The framework
		for jar in os.listdir(os.path.join(play_base, 'framework/lib')):
			if jar.endswith('.jar'):
				classpath.append(os.path.normpath(os.path.join(play_base, 'framework/lib/%s' % jar)))

		
		cp_args = ':'.join(classpath)
		if os.name == 'nt':
			cp_args = ';'.join(classpath)
	
	def check_jpda():
		global jpda_port
		try:
			s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
			s.bind(('127.0.0.1', int(jpda_port)))
			s.close()
		except socket.error, e:
			print 'JPDA port %s is already used. Will try to use any free port for debugging' % jpda_port
			jpda_port = 0
	
	# ~~~~~~~~~~~~~~~~~~~~~~~ Build java path
	def do_java(className='play.server.Server'):
		global java_cmd
		global java_path
		global pid_path
		global application_mode
		global jpda_port
		global log_path
		
		# ~~~~~~~~~~~~~~~~~~~~~~ JAVA_HOME/bin/java is used if defined
		if not os.environ.has_key('JAVA_HOME'):
			java_path = "java"
		else:
			java_path = os.path.normpath("%s/bin/java" % os.environ['JAVA_HOME'])
		
		for a in remaining_args:
			if a.find('--with') == 0:
				remaining_args.remove(a)
			if a.find('--%') == 0:
				remaining_args.remove(a)
		# ~~~~~~~~~~~~~~~~~~~~~~ Read some configuration from conf/application.conf
		java_args = remaining_args[:]
		
		memory_in_args=False
		for arg in java_args:
			if arg.startswith('-Xm'):
				memory_in_args=True
		if not memory_in_args:
			memory = readConf('jvm.memory')
			if memory:
				java_args = java_args + memory.split(' ')
		
		jpda_port = readConf('jpda.port')
		if not jpda_port:
			jpda_port = '8000'
		
		application_mode = readConf('application.mode')
		
		if application_mode == 'prod':
			java_args.append('-server')
		
		java_policy = readConf('java.policy')
		if not java_policy == '':
			policyFile = os.path.join(application_path, 'conf', java_policy)
			if os.path.exists(policyFile):
				print "~ using policy file \"%s\"" % policyFile
				java_args.append('-Djava.security.manager')
				java_args.append('-Djava.security.policy==%s' % policyFile)
		
		# The Java stuff
		java_cmd = [java_path, '-javaagent:%s' % agent_path] + java_args + ['-classpath', cp_args, '-Dapplication.path=%s' % application_path, '-Dplay.id=%s' % play_id, className]

		if not os.environ.has_key('PLAY_PID_PATH'):
			pid_path = os.path.join(application_path, 'server.pid');
		else:
			pid_path = os.environ['PLAY_PID_PATH'];
		
		if not os.environ.has_key('PLAY_LOG_PATH'):
			log_path = os.path.join(application_path, 'logs');
		else:
			log_path = os.environ['PLAY_LOG_PATH'];
		
		if not os.path.exists(log_path):
			os.mkdir(log_path);

	
	# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	# ~~~~~~~~~~~~~~~~~~~~~~ The commands ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	
	
	# ~~~~~~~~~~~~~~~~~~~~~~ [list-modules] Display the modules list
	if play_command == 'list-modules' or play_command == 'lm':
		print "~ You can also browse this list online at %s/modules" % modules_server
		print "~"
		
		modules_list = load_module_list()
		
		for mod in modules_list['modules']:
			print "~ [%s]" % mod['name']
			print "~   %s" % mod['fullname']
			print "~   %s/modules/%s" % (modules_server, mod['name'])
			
			vl = ''
			i = 0
			for v in mod['versions']:
				vl += v["version"]
				i = i+1
				if i < len(mod['versions']):
					vl += ', '
			
			if vl:
				print "~   Versions: %s" % vl
			else:
				print "~   (No versions released yet)"
			print "~"
		
		print "~ To install one of these modules use:"
		print "~ play install module-version (eg: play install scala-1.0)"
		print "~"
		print "~ Or you can just install the default release of a module using:"
		print "~ play install module (eg: play install scala)"
		print "~"
			
		sys.exit(0)
	
	# ~~~~~~~~~~~~~~~~~~~~~~ [build-module] Build a module
	if play_command == 'build-module' or play_command == 'bm':
		
		ftb = play_base
		
		try:
			optlist, args = getopt.getopt(remaining_args, '', ['framework='])
			for o, a in optlist:
				if o in ('--framework'):
					ftb = a
		except getopt.GetoptError, err:
			print "~ %s" % str(err)
			print "~ "
			sys.exit(-1)
		
		version = raw_input("~ What is the module version number? ")
		fwkMatch = raw_input("~ What are the playframework versions required? ")
		
		build_file = os.path.join(application_path, 'build.xml')
		if os.path.exists(build_file):
			print "~"
			print "~ Building..."
			print "~"
			os.system('ant -f %s -Dplay.path=%s' % (build_file, ftb) )
			print "~"
		
		mv = '%s-%s' % (os.path.basename(application_path), version)
		print("~ Packaging %s ... " % mv)
		
		dist_dir = os.path.join(application_path, 'dist')
		if os.path.exists(dist_dir):
			shutil.rmtree(dist_dir)
		os.mkdir(dist_dir)
		
		manifest = os.path.join(application_path, 'manifest')
		manifestF = open(manifest, 'w')
		manifestF.write('version=%s\nframeworkVersions=%s\n' % (version, fwkMatch))
		manifestF.close()
		
		zip = zipfile.ZipFile(os.path.join(dist_dir, '%s.zip' % mv), 'w', zipfile.ZIP_STORED)
		for (dirpath, dirnames, filenames) in os.walk(application_path):
			if dirpath == dist_dir:
				continue
			if dirpath.find('/.') > -1 or dirpath.find('/tmp/') > -1  or dirpath.find('/test-result/') > -1 or dirpath.find('/logs/') > -1 or dirpath.find('/eclipse/') > -1 or dirpath.endswith('/test-result') or dirpath.endswith('/logs')  or dirpath.endswith('/eclipse') or dirpath.endswith('/nbproject'):
				continue
			for file in filenames:
				if file.find('~') > -1 or file.endswith('.iml') or file.startswith('.'):
					continue
				zip.write(os.path.join(dirpath, file), os.path.join(dirpath[len(application_path):], file))
		zip.close()
		
		os.remove(manifest)
		
		print "~"
		print "~ Done!"
		print "~ Package is available at %s" % os.path.join(dist_dir, '%s.zip' % mv)
		print "~"
		
		sys.exit(0)

	# ~~~~~~~~~~~~~~~~~~~~~~ [install] Install a module
	if play_command == 'install':
		if len(sys.argv) < 3:
			help_file = os.path.join(play_base, 'documentation/commands/cmd-install.txt')
			print open(help_file, 'r').read()
			sys.exit(0)

		name = cmd = sys.argv[2]
		groups = re.match(r'^([a-zA-Z0-9]+)([-](.*))?$', name)
		module = groups.group(1)
		version = groups.group(3)
		
		modules_list = load_module_list()
		fetch = None
		
		for mod in modules_list['modules']:
			if mod['name'] == module:
				for v in mod['versions']:
					if version == None and v['isDefault']:
						print '~ This module is compatible with: %s' % v['matches']
						ok = raw_input('~ Do you want to install this version (y/n)? ')
						if not ok == 'y':
							print '~'
							sys.exit(-1)
						print '~ Installing module %s-%s...' % (module, v['version'])
						fetch = '%s/modules/%s-%s.zip' % (modules_server, module, v['version'])
						break
					if version  == v['version']:
						print '~ This module is compatible with: %s' % v['matches']
						ok = raw_input('~ Do you want to install this version (y/n)? ')
						if not ok == 'y':
							print '~'
							sys.exit(-1)

						print '~ Installing module %s-%s...' % (module, v['version'])
						fetch = '%s/modules/%s-%s.zip' % (modules_server, module, v['version'])
						break
						
		if fetch == None:
			print '~ No module found \'%s\'' % name
			print '~ Try play list-modules to get the modules list'
			print '~'
			sys.exit(-1)
		
		archive = os.path.join(play_base, 'modules/%s-%s.zip' % (module, v['version']))
		if os.path.exists(archive):
			os.remove(archive)
		
		print '~'
		print '~ Fetching %s' % fetch
		Downloader().retrieve(fetch, archive)
		
		if not os.path.exists(archive):
			print '~ Oops, file does not exist'
			print '~'
			sys.exist(-1)
		
		print '~ Unzipping...'
		
		if os.path.exists(os.path.join(play_base, 'modules/%s-%s' % (module, v['version']))):
			shutil.rmtree(os.path.join(play_base, 'modules/%s-%s' % (module, v['version'])))
		os.mkdir(os.path.join(play_base, 'modules/%s-%s' % (module, v['version'])))
		
		Unzip().extract(archive, os.path.join(play_base, 'modules/%s-%s' % (module, v['version'])))
		os.remove(archive)
		print '~'
		print '~ Module %s-%s is installed!' % (module, v['version'])
		print '~ You can now use it by add adding this line to application.conf file:'
		print '~'
		print '~ module.%s=${play.path}/modules/%s-%s' % (module, module, v['version'])
		print '~'
		sys.exit(0)

	# ~~~~~~~~~~~~~~~~~~~~~~ [help] Display help
	if play_command == 'help':
		if len(sys.argv) == 3:
			cmd = sys.argv[2]
		else:
			cmd = 'all'
		help_file = os.path.join(play_base, 'documentation/commands/cmd-%s.txt' % cmd)
		if os.path.exists(help_file):
			print open(help_file, 'r').read()
			sys.exit(0)
		else:
			print '~ Oops, command \'%s\' not found. Try just \'play help\' to list all commands.' % cmd
			print '~'
			sys.exit(-1)

	
	# ~~~~~~~~~~~~~~~~~~~~~~ [id] Define the framework ID
	if play_command == 'id':
		if not play_id:
			print "~ framework ID is not set"
		new_id = raw_input("~ What is the new framework ID (or blank to unset)? ")
		if new_id:
			print "~"
			print "~ OK, the framework ID is now %s" % new_id
			print "~"
			open(id_file, 'w').write(new_id)
		else:
			print "~"
			print "~ OK, the framework ID is unset"
			print "~"
			if os.path.exists(id_file):
				os.remove(id_file)
		sys.exit(0)

	
	# ~~~~~~~~~~~~~~~~~~~~~~ [new] Create a new application
	if play_command == 'new' or play_command == 'new,run':
		withModules = []
		application_name = None
		try:
			optlist, args = getopt.getopt(remaining_args, '', ['with=', 'name='])
			for o, a in optlist:
				if o in ('--with'):
					withModules = a.split(',')
				if o in ('--name'):
					application_name = a
		except getopt.GetoptError, err:
			print "~ %s" % str(err)
			print "~ Sorry, unrecognized option"
			print "~ "
			sys.exit(-1)
		if os.path.exists(application_path):
			print "~ Oops. %s already exists" % application_path
			print "~"
			sys.exit(-1)
		
		md = []
		for m in withModules:
			dirname = None
			if os.path.exists(os.path.join(play_base, 'modules/%s' % m)) and os.path.isdir(os.path.join(play_base, 'modules/%s' % m)):
				dirname = m
			else:
				for f in os.listdir(os.path.join(play_base, 'modules')):
					if os.path.isdir(os.path.join(play_base, 'modules/%s' % f)) and f.find('%s-' % m) == 0:
						dirname = f
						break
			
			if not dirname:
				print "~ Oops. No module %s found" % m
				print "~ Try to install it using 'play install %s'" % m
				print "~"
				sys.exit(-1)
			
			md.append(dirname)
			
		print "~ The new application will be created in %s" % os.path.normpath(application_path)
		if application_name is None:
		    application_name = raw_input("~ What is the application name? ")
		shutil.copytree(os.path.join(play_base, 'resources/application-skel'), application_path)
		check_application()
		replaceAll(os.path.join(application_path, 'conf/application.conf'), r'%APPLICATION_NAME%', application_name)
		replaceAll(os.path.join(application_path, 'conf/application.conf'), r'%SECRET_KEY%', secretKey())
		print "~"
		
		for m in md:
			mn = m
			if mn.find('-') > 0:
				mn = mn[:mn.find('-')]
			replaceAll(os.path.join(application_path, 'conf/application.conf'), r'# ---- MODULES ----', '# ---- MODULES ----\nmodule.%s=${play.path}/modules/%s' % (mn, m) )
		
		# modules
		check_application()
		load_modules()
		for module in modules:
			commands = os.path.join(module, 'commands.py')
			if os.path.exists(commands):
				execfile(commands)
		
		print "~ OK, the application is created."
		print "~ Start it with : play run %s" % sys.argv[2]
		print "~ Have fun!"
		print "~"
		if play_command == 'new': sys.exit(0)
		
	# ~~~~~~~~~~~~~~~~~~~~~~ [new-module] Create a new module
	if play_command == 'new-module':
		if os.path.exists(application_path):
			print "~ Oops. %s already exists" % application_path
			print "~"
			sys.exit(-1)
			
		print "~ The new module will be created in %s" % os.path.normpath(application_path)
		print "~"
		application_name = os.path.basename(application_path)
		shutil.copytree(os.path.join(play_base, 'resources/module-skel'), application_path)
		# check_application()
		replaceAll(os.path.join(application_path, 'build.xml'), r'%MODULE%', application_name)
		replaceAll(os.path.join(application_path, 'conf/messages'), r'%MODULE%', application_name)
		replaceAll(os.path.join(application_path, 'conf/routes'), r'%MODULE%', application_name)
		replaceAll(os.path.join(application_path, 'conf/routes'), r'%MODULE_LOWERCASE%', string.lower(application_name))
		os.mkdir(os.path.join(application_path, 'app/controllers/%s' % application_name))
		os.mkdir(os.path.join(application_path, 'app/models/%s' % application_name))
		os.mkdir(os.path.join(application_path, 'app/views/%s' % application_name))
		os.mkdir(os.path.join(application_path, 'app/views/tags/%s' % application_name))
		os.mkdir(os.path.join(application_path, 'src/play/modules/%s' % application_name))
		
		print "~ OK, the module is created."
		print "~ Start using it by adding this line in the application.conf modules list: "
		print "~ module.%s=%s" % (application_name, os.path.normpath(application_path))
		print "~"
		print "~ Have fun!"
		print "~"
		
		sys.exit(0)
		

	# ~~~~~~~~~~~~~~~~~~~~~~ [secret] Generate a new secret key
	if play_command == 'secret':
		check_application()
		print "~ Generating the secret key..."
		sk = secretKey()
		replaceAll(os.path.join(application_path, 'conf/application.conf'), r'application.secret=.*', 'application.secret=%s' % sk)
		print "~ Keep the secret : %s" % sk
		print "~"
		sys.exit(0)

	
	# ~~~~~~~~~~~~~~~~~~~~~~ [clean] Clean temporary files
	if play_command == 'clean' or play_command == 'clean,run':
		check_application()
		print "~ Deleting %s" % os.path.normpath(os.path.join(application_path, 'tmp'))
		if os.path.exists(os.path.join(application_path, 'tmp')):
			shutil.rmtree(os.path.join(application_path, 'tmp'))
		print "~"
		if play_command == 'clean': sys.exit(0)
		
	
	# ~~~~~~~~~~~~~~~~~~~~~~ [modules] Display the application modules
	if play_command == 'modules':
		check_application()
		load_modules()
		if len(modules):
			print "~ Application modules are:"
			print "~ "
			for module in modules:
				print "~ %s" % module
		else:
			print "~ No modules installed in this application"
		print "~ "
		sys.exit(0)
	
	
	# ~~~~~~~~~~~~~~~~~~~~~~ [war] Generate a WAR
		
	def package_as_war(war_path, war_zip_path):
		check_application()
		load_modules()
		do_classpath()
		do_java()
		
		if not war_path:
			print "~ Oops. Please specify a path where to generate the WAR, using the -o or --output option"
			print "~"
			sys.exit(-1)
		
		if os.path.exists(war_path) and not os.path.exists(os.path.join(war_path, 'WEB-INF')):
			print "~ Oops. The destination path already exists but does not seem to host a valid WAR structure"
			print "~"
			sys.exit(-1)
			
		if isParentOf(application_path, war_path):
			print "~ Oops. Please specify a destination directory outside of the application"
			print "~"
			sys.exit(-1)
			
		print "~ Packaging current version of the framework and the application to %s ..." % (os.path.normpath(war_path))
		if os.path.exists(war_path): shutil.rmtree(war_path)
		if os.path.exists(os.path.join(application_path, 'war')):
			shutil.copytree(os.path.join(application_path, 'war'), war_path)
		else:
			os.mkdir(war_path)
		if not os.path.exists(os.path.join(war_path, 'WEB-INF')): os.mkdir(os.path.join(war_path, 'WEB-INF'))
		if not os.path.exists(os.path.join(war_path, 'WEB-INF/web.xml')):
		    shutil.copyfile(os.path.join(play_base, 'resources/war/web.xml'), os.path.join(war_path, 'WEB-INF/web.xml'))
		application_name = readConf('application.name')
		replaceAll(os.path.join(war_path, 'WEB-INF/web.xml'), r'%APPLICATION_NAME%', application_name)
		if play_id:
			replaceAll(os.path.join(war_path, 'WEB-INF/web.xml'), r'%PLAY_ID%', play_id)
		else:
			replaceAll(os.path.join(war_path, 'WEB-INF/web.xml'), r'%PLAY_ID%', 'war')
		if os.path.exists(os.path.join(war_path, 'WEB-INF/application')): shutil.rmtree(os.path.join(war_path, 'WEB-INF/application'))
		shutil.copytree(application_path, os.path.join(war_path, 'WEB-INF/application'))
		if os.path.exists(os.path.join(war_path, 'WEB-INF/application/war')):
			shutil.rmtree(os.path.join(war_path, 'WEB-INF/application/war'))
		if os.path.exists(os.path.join(war_path, 'WEB-INF/application/logs')):
			shutil.rmtree(os.path.join(war_path, 'WEB-INF/application/logs'))
		shutil.copytree(os.path.join(application_path, 'conf'), os.path.join(war_path, 'WEB-INF/classes'))
		if os.path.exists(os.path.join(war_path, 'WEB-INF/lib')): shutil.rmtree(os.path.join(war_path, 'WEB-INF/lib'))
		os.mkdir(os.path.join(war_path, 'WEB-INF/lib'))
		for jar in classpath:
			if jar.endswith('.jar') and jar.find('provided-') == -1:
				shutil.copyfile(jar, os.path.join(war_path, 'WEB-INF/lib/%s' % os.path.split(jar)[1]))
		if os.path.exists(os.path.join(war_path, 'WEB-INF/framework')): shutil.rmtree(os.path.join(war_path, 'WEB-INF/framework'))
		os.mkdir(os.path.join(war_path, 'WEB-INF/framework'))
		shutil.copytree(os.path.join(play_base, 'framework/templates'), os.path.join(war_path, 'WEB-INF/framework/templates'))
		
		# modules
		for module in modules:
			to = os.path.join(war_path, 'WEB-INF/modules/%s' % os.path.basename(module))
			shutil.copytree(module, to)
			if os.path.exists(os.path.join(to, 'src')):
				shutil.rmtree(os.path.join(to, 'src'))
			if os.path.exists(os.path.join(to, 'dist')):
				shutil.rmtree(os.path.join(to, 'dist'))
			if os.path.exists(os.path.join(to, 'samples-and-tests')):
				shutil.rmtree(os.path.join(to, 'samples-and-tests'))
			if os.path.exists(os.path.join(to, 'build.xml')):
				os.remove(os.path.join(to, 'build.xml'))
		pm = readConfs('module.')
		for m in pm:
			nm = os.path.basename(m)
			replaceAll(os.path.join(war_path, 'WEB-INF/application/conf/application.conf'), m, '../modules/%s' % nm)
		
		if not os.path.exists(os.path.join(war_path, 'WEB-INF/resources')): os.mkdir(os.path.join(war_path, 'WEB-INF/resources'))
		shutil.copyfile(os.path.join(play_base, 'resources/messages'), os.path.join(war_path, 'WEB-INF/resources/messages'))
		
		# Module-specific modifications
		for module in modules:
			commands = os.path.join(module, 'commands.py')
			if os.path.exists(commands):
				execfile(commands)
		
		if war_zip_path:
			print "~ Creating zipped archive to %s ..." % (os.path.normpath(war_zip_path))
			if os.path.exists(war_zip_path):
				os.remove(war_zip_path)
			zip = zipfile.ZipFile(war_zip_path, 'w', zipfile.ZIP_STORED)
			dist_dir = os.path.join(application_path, 'dist')
			for (dirpath, dirnames, filenames) in os.walk(war_path):
				if dirpath == dist_dir:
					continue
				if dirpath.find('/.') > -1:
					continue
				for file in filenames:
					if file.find('~') > -1 or file.startswith('.'):
						continue
					zip.write(os.path.join(dirpath, file), os.path.join(dirpath[len(war_path):], file))

			zip.close()

	if play_command == 'war':
		war_path = None
		war_zip_path = None
		try:
			optlist, args = getopt.getopt(remaining_args, 'o:', ['output=', 'zip'])
			for o, a in optlist:
				if o in ('-o', '--output'):
					war_path = os.path.normpath(os.path.abspath(a))
			for o, a in optlist:
				if o in ('--zip'):
					war_zip_path = war_path + '.war'
		except getopt.GetoptError, err:
			print "~ %s" % str(err)
			print "~ Please specify a path where to generate the WAR, using the -o or --output option"
			print "~ "
			sys.exit(-1)
			
		package_as_war(war_path, war_zip_path)
		
		print "~ Done !"
		print "~"
		print "~ You can now load %s as a standard WAR into your servlet container" % (os.path.normpath(war_path))
		print "~ You can't use play standard commands to run/stop/debug the WAR application..."
		print "~ ... just use your servlet container commands instead"
		print "~"
		print "~ Have fun!"
		print "~"
		sys.exit(0)

	
	# ~~~~~~~~~~~~~~~~~~~~~~ [cp] Display the application classpath
	if play_command == 'cp' or play_command == 'classpath':
		check_application()
		load_modules()
		do_classpath()
		print "~ Computed classpath is:"
		print "~ "
		print cp_args
		print "~ "
		sys.exit(0)
		
	
	# ~~~~~~~~~~~~~~~~~~~~~~ [run] Run the application
	if play_command == 'run' or play_command == 'new,run' or play_command == 'clean,run':
		check_application()
		load_modules()
		do_classpath()
		disable_check_jpda = False
		if remaining_args.count('-f') == 1:
			disable_check_jpda = True
			remaining_args.remove('-f')
		do_java()
		print "~ Ctrl+C to stop"
		print "~ "
		if application_mode == 'dev':
			if not disable_check_jpda: check_jpda()
			java_cmd.insert(2, '-Xdebug')
			java_cmd.insert(2, '-Xrunjdwp:transport=dt_socket,address=%s,server=y,suspend=n' % jpda_port)
			java_cmd.insert(2, '-Dplay.debug=yes')
		try:
			subprocess.call(java_cmd, env=os.environ)
		except OSError:
			print "Could not execute the java executable, please make sure the JAVA_HOME environment variable is set properly (the java executable should reside at JAVA_HOME/bin/java). "
			sys.exit(-1)
		print
		sys.exit(0)
	
	
	# ~~~~~~~~~~~~~~~~~~~~~~ [status] Get application status
	if play_command == 'status' or play_command == 'st':
		url = ''
		secret_key = ''
		
		try:
			optlist, args = getopt.getopt(remaining_args, '', ['url=', 'secret='])
			for o, a in optlist:
				if o in ('--url'):
					if a.endswith('/'):
						url = a + '@status'
					else:
						url = a + '/@status'
				if o in ('--secret'):
					secret_key = a
		except getopt.GetoptError, err:
			print "~ %s" % str(err)
			print "~ "
			sys.exit(-1)
		
		if not url or not secret_key:
			check_application()
			if not url:
				http_port = readConf('http.port')
				if not http_port:
					http_port = 9000
				else:
					http_port = int(http_port)
				url = 'http://localhost:%s/@status' % http_port
			if not secret_key:
				secret_key = readConf('application.secret')
		
		import hmac
		from hashlib import sha1 as sha
		
		hm = hmac.new(secret_key, '@status', sha)
		authorization = hm.hexdigest()
		
		try:
			proxy_handler = urllib2.ProxyHandler({})
			req = urllib2.Request(url)
			req.add_header('Authorization', authorization)
			opener = urllib2.build_opener(proxy_handler)
			status = opener.open(req);
			print '~ Status from %s,' % url
			print '~'
			print status.read()
			print '~'
		except urllib2.HTTPError, e:
			print "~ Cannot retrieve the application status... (%s)" % (e.code)
			print "~"
			sys.exit(-1)
		except urllib2.URLError, e:
			print "~ Cannot contact the application..."
			print "~"
			sys.exit(-1)
		print
		sys.exit(0)

	
	# ~~~~~~~~~~~~~~~~~~~~~~ [test] Run the application tests
	if play_command == 'test':
		check_application()
		load_modules()
		do_classpath()
		disable_check_jpda = False
		if remaining_args.count('-f') == 1:
			disable_check_jpda = True
			remaining_args.remove('-f')
		do_java()
		print "~ Running in test mode"
		print "~ Ctrl+C to stop"
		print "~ "
		check_jpda()
		java_cmd.insert(2, '-Xdebug')
		java_cmd.insert(2, '-Xrunjdwp:transport=dt_socket,address=%s,server=y,suspend=n' % jpda_port)
		java_cmd.insert(2, '-Dplay.debug=yes')
		try:
			subprocess.call(java_cmd, env=os.environ)
		except OSError:
			print "Could not execute the java executable, please make sure the JAVA_HOME environment variable is set properly (the java executable should reside at JAVA_HOME/bin/java). "
			sys.exit(-1)
		print
		sys.exit(0)
		
	
	# ~~~~~~~~~~~~~~~~~~~~~~ [auto-test] Run the application tests
	if play_command == 'auto-test':
		check_application()
		load_modules()
		do_classpath()
		do_java()
		print "~ Running in test mode"
		print "~ Ctrl+C to stop"
		print "~ "
		print "~ Deleting %s" % os.path.normpath(os.path.join(application_path, 'tmp'))
		if os.path.exists(os.path.join(application_path, 'tmp')):
			shutil.rmtree(os.path.join(application_path, 'tmp'))
		print "~"
		test_result = os.path.join(application_path, 'test-result')
		if os.path.exists(test_result):
			shutil.rmtree(test_result)
		sout = open(os.path.join(log_path, 'system.out'), 'w')
		try:
			play_process = subprocess.Popen(java_cmd, env=os.environ, stdout=sout)
		except OSError:
			print "Could not execute the java executable, please make sure the JAVA_HOME environment variable is set properly (the java executable should reside at JAVA_HOME/bin/java). "
			sys.exit(-1)
		soutint = open(os.path.join(log_path, 'system.out'), 'r')
		while True:
			if play_process.poll():
				print "~"
				print "~ Oops, application has not started?"
				print "~"
				sys.exit(-1)
			line = soutint.readline().strip()
			if line:
				print line
				if line.find('Listening for HTTP') > -1:
					soutint.close()
					break
		# Launch the browser
		print "~"
		print "~ Loading the test runner at %s ..." % ('http://localhost:%s/@tests' % http_port)
		try:
			proxy_handler = urllib2.ProxyHandler({})
			opener = urllib2.build_opener(proxy_handler)
			opener.open('http://localhost:%s/@tests' % http_port);
		except urllib2.HTTPError, e:
			print "~"
			print "~ There are compilation errors... (%s)" % (e.code)
			print "~"
			kill(play_process.pid)
			sys.exit(-1)
		print "~ Launching a web browser at http://localhost:%s/@tests?select=all&auto=yes ..." % http_port
		webbrowser.open('http://localhost:%s/@tests?select=all&auto=yes' % http_port)
		while True:
			time.sleep(1)
			if os.path.exists(os.path.join(application_path, 'test-result/result.passed')):
				print "~"
				print "~ All tests passed"
				print "~"
				kill(play_process.pid)
				break
			if os.path.exists(os.path.join(application_path, 'test-result/result.failed')):
				print "~"
				print "~ Some tests have failed. See file://%s for results" % test_result
				print "~"
				kill(play_process.pid)
				break
		sys.exit(0)

	
	# ~~~~~~~~~~~~~~~~~~~~~~ [precompile] Precompile
	if play_command == 'precompile':
		check_application()
		load_modules()
		do_classpath()
		do_java()
		if os.path.exists(os.path.join(application_path, 'tmp')):
			shutil.rmtree(os.path.join(application_path, 'tmp'))
		if os.path.exists(os.path.join(application_path, 'precompiled')):
			shutil.rmtree(os.path.join(application_path, 'precompiled'))
		java_cmd.insert(2, '-Dprecompile=yes')
		try:
			subprocess.call(java_cmd, env=os.environ)
		except OSError:
			print "Could not execute the java executable, please make sure the JAVA_HOME environment variable is set properly (the java executable should reside at JAVA_HOME/bin/java). "
			sys.exit(-1)
		print
		sys.exit(0)

	
	# ~~~~~~~~~~~~~~~~~~~~~~ [start] Start the application
	if play_command == 'start':
		check_application()
		load_modules()
		do_classpath()
		do_java()
		if os.path.exists(pid_path):
			print "~ Oops. %s is already started! (or delete %s)" % (os.path.normpath(application_path), os.path.normpath(pid_path))
			print "~"
			sys.exit(1)
		
		sysout = readConf('application.log.system.out')
		sysout = sysout!='false' and sysout!='off'
		if not sysout:
		  sout = None
		else:
		  sout = open(os.path.join(log_path, 'system.out'), 'w')
		try:
			pid = subprocess.Popen(java_cmd, stdout=sout, env=os.environ).pid
		except OSError:
			print "Could not execute the java executable, please make sure the JAVA_HOME environment variable is set properly (the java executable should reside at JAVA_HOME/bin/java). "
			sys.exit(-1)
		print "~ OK, %s is started" % os.path.normpath(application_path)
		if sysout:
		  print "~ output is redirected to %s" % os.path.normpath(os.path.join(log_path, 'system.out'))
		pid_file = open(pid_path, 'w')
		pid_file.write(str(pid))
		print "~ pid is %s" % pid
		print "~"
		sys.exit(0)

	
	# ~~~~~~~~~~~~~~~~~~~~~~ [stop] Stop the application
	if play_command == 'stop':
		check_application()
		load_modules()
		do_classpath()
		do_java()
		if not os.path.exists(pid_path):
			print "~ Oops! %s is not started (server.pid not found)" % os.path.normpath(application_path)
			print "~"
			sys.exit(-1)
		pid = open(pid_path).readline().strip()
		os.remove(pid_path)
		kill(pid)
		print "~ OK, %s is stopped" % application_path
		print "~"
		sys.exit(0)

	
	# ~~~~~~~~~~~~~~~~~~~~~~ [restart] Restart the application
	if play_command == 'restart':
		check_application()
		load_modules()
		do_classpath()
		do_java()
		if not os.path.exists(pid_path):
			print "~ Oops! %s is not started (server.pid not found)" % os.path.normpath(application_path)
			print "~"
		else:
			pid = open(pid_path).readline().strip()
			os.remove(pid_path)
			kill(pid)

		
		sysout = readConf('application.log.system.out')
		sysout = sysout!='false' and sysout!='off'
		if not sysout:
		  sout = None
		else:
		  sout = open(os.path.join(log_path, 'system.out'), 'w')
		try:
			pid = subprocess.Popen(java_cmd, stdout=sout, env=os.environ).pid
		except OSError:
			print "Could not execute the java executable, please make sure the JAVA_HOME environment variable is set properly (the java executable should reside at JAVA_HOME/bin/java). "
			sys.exit(-1)
		print "~ OK, %s is restarted" % os.path.normpath(application_path)
		if sysout:
		  print "~ output is redirected to %s" % os.path.normpath(os.path.join(log_path, 'system.out'))
		pid_file = open(pid_path, 'w')
		pid_file.write(str(pid))
		print "~ New pid is %s" % pid
		print "~"
		sys.exit(0)

	
	# ~~~~~~~~~~~~~~~~~~~~~~ [pid] Display the pid of the running application
	if play_command == 'pid':
		check_application()
		load_modules()
		do_classpath()
		do_java()
		if not os.path.exists(pid_path):
			print "~ Oops! %s is not started (server.pid not found)" % os.path.normpath(application_path)
			print "~"
			sys.exit(-1)
		pid = open(pid_path).readline().strip()
		print "~ PID of the running applications is %s" % pid
		print "~ "
		sys.exit(0)

	
	# ~~~~~~~~~~~~~~~~~~~~~~ [out] Follow logs of the running application
	if play_command == 'out':
		check_application()
		load_modules()
		do_classpath()
		do_java()
		if not os.path.exists(os.path.join(log_path, 'system.out')):
			print "~ Oops! %s not found" % os.path.normpath(os.path.join(log_path, 'system.out'))
			print "~"
			sys.exit(-1)
		sout = open(os.path.join(log_path, 'system.out'), 'r')
		try:
			sout.seek(-5000, os.SEEK_END)
		except IOError:
			sout.seek(0)
		while True:
			where = sout.tell()
			line = sout.readline().strip()
			if not line:
				time.sleep(1)
				sout.seek(where)
			else:
				print line

	# ~~~~~~~~~~~~~~~~~~~~~~ [javadoc] Generates the javadoc for the project
	if play_command == 'jd' or play_command == 'javadoc':
		check_application()
		load_modules()
		do_classpath()
		do_java()
		if not os.environ.has_key('JAVA_HOME'):
			javadoc_path = "javadoc"
		else:
			javadoc_path = os.path.normpath("%s/bin/javadoc" % os.environ['JAVA_HOME'])

		fileList = []
		def add_java_files(app_path):
			for root, subFolders, files in os.walk(os.path.join(app_path, 'app')):
				for file in files:
					if file.endswith(".java"):
						fileList.append(os.path.join(root, file))
		add_java_files(application_path)
		for module in modules:
			add_java_files(os.path.normpath(module))
		outdir = os.path.join(application_path, 'javadoc')
		sout = open(os.path.join(log_path, 'javadoc.log'), 'w')
		serr = open(os.path.join(log_path, 'javadoc.err'), 'w')
		if (os.path.isdir(outdir)):
			shutil.rmtree(outdir)
		javadoc_cmd = [javadoc_path, '-classpath', cp_args, '-d', outdir] + fileList
		print "Generating Javadoc in " + outdir + "..."
		subprocess.call(javadoc_cmd, env=os.environ, stdout=sout, stderr=serr)
		print "Done! You can open " + os.path.join(outdir, 'overview-tree.html') + " in your browser."
		sys.exit(0)

	# ~~~~~~~~~~~~~~~~~~~~~~ [netbeansify] Create netbeans configuration files
	if play_command == 'nb' or play_command == 'netbeansify':
		check_application()
		load_modules()
		do_classpath()
		application_name = readConf('application.name')
		if not application_name:
			application_name = os.path.dirname(application_path)
		nbproject = os.path.join(application_path, 'nbproject')
		if os.path.exists(nbproject):
			shutil.rmtree(nbproject)
			if os.name == 'nt':
				time.sleep(1)
		shutil.copytree(os.path.join(play_base, 'resources/_nbproject'), nbproject)
		replaceAll(os.path.join(nbproject, 'project.xml'), r'%APPLICATION_NAME%', application_name)
		replaceAll(os.path.join(nbproject, 'project.xml'), r'%ANT_SCRIPT%', os.path.normpath(os.path.join(play_base, 'framework/build.xml')))
		replaceAll(os.path.join(nbproject, 'project.xml'), r'%APPLICATION_PATH%', os.path.normpath(application_path))
		if os.name == 'nt':
			replaceAll(os.path.join(nbproject, 'project.xml'), r'%PLAY_CLASSPATH%', ';'.join(classpath + ['nbproject\\classes']))
		else:
			replaceAll(os.path.join(nbproject, 'project.xml'), r'%PLAY_CLASSPATH%', ':'.join(classpath + ['nbproject/classes']))
		mr = ""
		for module in modules:
			mr += "<package-root>%s</package-root>" % os.path.normpath(os.path.join(module, 'app'))
		replaceAll(os.path.join(nbproject, 'project.xml'), r'%MODULES%', mr)
		mr = ""
		for dir in os.listdir(application_path):
			if os.path.isdir(os.path.join(application_path, dir)) and dir not in ['app', 'conf', 'test', 'test-result', 'public', 'tmp', 'logs', 'nbproject', 'lib']:
				mr = '<source-folder style="tree"><label>%s</label><location>%s</location></source-folder>' % (dir, dir)
		replaceAll(os.path.join(nbproject, 'project.xml'), r'%MORE%', mr)
		print "~ OK, the application is ready for netbeans"
		print "~ Just open %s as a netbeans project" % os.path.normpath(application_path)
		print "~"
		print "~ Use netbeansify again when you want to update netbeans configuration files, then close and open you project again."
		print "~"
		sys.exit(0)

	
	# ~~~~~~~~~~~~~~~~~~~~~~ [eclipsify] Create eclipse configuration files
	if play_command == 'ec' or play_command == 'eclipsify':
		check_application()
		load_modules()
		do_classpath()
		do_java()
		application_name = readConf('application.name')
		if not application_name:
			application_name = os.path.dirname(application_path)
		dotProject = os.path.join(application_path, '.project')
		dotClasspath = os.path.join(application_path, '.classpath')
		dotSettings = os.path.join(application_path, '.settings')
		eclipse = os.path.join(application_path, 'eclipse')
		if os.path.exists(eclipse):
			shutil.rmtree(eclipse)
			if os.name == 'nt':
				time.sleep(1)
		
		if os.path.exists(dotSettings):
			shutil.rmtree(dotSettings)
			if os.name == 'nt':
				time.sleep(1)
		
		shutil.copyfile(os.path.join(play_base, 'resources/eclipse/.project'), dotProject)
		shutil.copyfile(os.path.join(play_base, 'resources/eclipse/.classpath'), dotClasspath)
		shutil.copytree(os.path.join(play_base, 'resources/eclipse'), eclipse)
		shutil.copytree(os.path.join(play_base, 'resources/eclipse/.settings'), dotSettings)
		replaceAll(dotProject, r'%PROJECT_NAME%', application_name)
		
		playJarPath = os.path.join(play_base, 'framework','play.jar')
		playSourcePath = os.path.dirname(playJarPath)
		if os.name == 'nt':
			playSourcePath=playSourcePath.replace('\\','/').capitalize()
		
		cpXML = ""
		for el in classpath:
			if not os.path.basename(el) == "conf":
				if el == playJarPath:
					cpXML += '<classpathentry kind="lib" path="%s" sourcepath="%s" />\n\t' % (os.path.normpath(el) , playSourcePath)
				else:
					cpXML += '<classpathentry kind="lib" path="%s" />\n\t' % os.path.normpath(el)
		replaceAll(dotClasspath, r'%PROJECTCLASSPATH%', cpXML)
		
		if len(modules):
			lXML = ""
			cXML = ""
			for module in modules:
				lXML += '<link><name>%s</name><type>2</type><location>%s</location></link>\n' % (os.path.basename(module), os.path.join(module, 'app').replace('\\', '/'))
				if os.path.exists(os.path.join(module, "conf")):
					lXML += '<link><name>conf/%s</name><type>2</type><location>%s/conf</location></link>\n' % (os.path.basename(module), module.replace('\\', '/'))
				if os.path.exists(os.path.join(module, "public")):
					lXML += '<link><name>public/%s</name><type>2</type><location>%s/public</location></link>\n' % (os.path.basename(module), module.replace('\\', '/'))
				cXML += '<classpathentry kind="src" path="%s"/>' % (os.path.basename(module))
			replaceAll(dotProject, r'%LINKS%', '<linkedResources>%s</linkedResources>' % lXML)
			replaceAll(dotClasspath, r'%MODULES%', cXML)
		else:
			replaceAll(dotProject, r'%LINKS%', '')
			replaceAll(dotClasspath, r'%MODULES%', '')
		
		replaceAll(os.path.join(application_path, 'eclipse/debug.launch'), r'%PROJECT_NAME%', application_name)
		replaceAll(os.path.join(application_path, 'eclipse/debug.launch'), r'%PLAY_BASE%', play_base)
		replaceAll(os.path.join(application_path, 'eclipse/debug.launch'), r'%PLAY_ID%', play_id)
		replaceAll(os.path.join(application_path, 'eclipse/debug.launch'), r'%JPDA_PORT%', jpda_port)
		
		replaceAll(os.path.join(application_path, 'eclipse/test.launch'), r'%PROJECT_NAME%', application_name)
		replaceAll(os.path.join(application_path, 'eclipse/test.launch'), r'%PLAY_BASE%', play_base)
		replaceAll(os.path.join(application_path, 'eclipse/test.launch'), r'%PLAY_ID%', play_id)
		replaceAll(os.path.join(application_path, 'eclipse/test.launch'), r'%JPDA_PORT%', jpda_port)
		
		replaceAll(os.path.join(application_path, 'eclipse/connect.launch'), r'%PROJECT_NAME%', application_name)
		replaceAll(os.path.join(application_path, 'eclipse/connect.launch'), r'%JPDA_PORT%', jpda_port)
		
		os.rename(os.path.join(application_path, 'eclipse/connect.launch'), os.path.join(application_path, 'eclipse/Connect JPDA to %s.launch' % application_name))
		os.rename(os.path.join(application_path, 'eclipse/test.launch'), os.path.join(application_path, 'eclipse/Test %s.launch' % application_name))
		os.rename(os.path.join(application_path, 'eclipse/debug.launch'), os.path.join(application_path, 'eclipse/%s.launch' % application_name))
		
		# Module-specific modifications
		for module in modules:
			commands = os.path.join(module, 'commands.py')
			if os.path.exists(commands):
				execfile(commands)
		
		print "~ OK, the application is ready for eclipse"
		print "~ Use File/Import/General/Existing project to import %s into eclipse" % os.path.normpath(application_path)
		print "~"
		print "~ Use eclipsify again when you want to update eclipse configuration files."
		print "~ However, it's often better to delete and re-import the project into your workspace since eclipse keeps dirty caches..."
		print "~"
		
		sys.exit(0)

	
	# ~~~~~~~~~~~~~~~~~~~~~~ [idealize] Create idea intellij configuration files
	if play_command == 'idea' or play_command == 'idealize':
		check_application()
		load_modules()
		do_classpath()
		do_java()
		application_name = readConf('application.name')
		imlFile = os.path.join(application_path, application_name + '.iml')
		shutil.copyfile(os.path.join(play_base, 'resources/idea/imlTemplate.xml'), imlFile)
		cpXML = ""
		
		replaceAll(imlFile, r'%PLAYHOME%', play_base.replace('\\', '/'))
		
		if len(modules):
			lXML = ""
			cXML = ""
			for module in modules:
				lXML += '    <content url="file://%s">\n      <sourceFolder url="file://%s" isTestSource="false" />\n    </content>\n' % (module, os.path.join(module, 'app').replace('\\', '/'))
			replaceAll(imlFile, r'%LINKS%', lXML)
		else:
			replaceAll(imlFile, r'%LINKS%', '')
		
		print "~ OK, the application is ready for Intellij Idea"
		print "~ Use File/New Module/Import Existing module"
		print "~"
		
		sys.exit(0)

	
	
	# Module command ?
	if play_command.find(':') > 0:
		check_application()
		load_modules()
		for module in modules:
			commands = os.path.join(module, 'commands.py')
			if os.path.exists(commands):
				execfile(commands)

	
	# ~~~~~~~~~~~~~~~~~~~~~~ Invalid command
	print "~ Usage: play cmd [app_path] [--options]"
	print "~ "
	print "~ with,  new      Create a new application"
	print "~        run      Run the application in the current shell"
	print "~        help     Show play help"
	print "~"
	if len(sys.argv) > 1:
		print "~ Invalid command: %s" % sys.argv[1]
		print "~"
	sys.exit(-1)


except KeyboardInterrupt:
	print '~ ...'
	sys.exit(0)



h1. Deployment options

Play applications can be deployed virtually anywhere: inside Servlet containers, as standalone servers, on Heroku, Google Application Engine, Stack, a Cloud, etc...

h2. <a name="standalone">Standalone Play applications</a>

The simplest and the most robust way is to simply run your Play application without any container. You can use a frontal HTTP server like Lighttpd or Apache if you need more advanced HTTP features like virtual hosting.

The built-in HTTP server can serve thousands of HTTP requests per second so it will never be the performance bottleneck. Moreover it uses a more efficient threading model (where a Servlet container uses 1 thread per request). Different "modules":http://playframework.org/modules allow you to use different servers (Grizzly, Netty, etc...) as well.

Those servers support long polling and allow to manage very long requests (waiting for a long task to complete), and direct streaming of File objects (and any InputStream if you specify the Content-Length), without blocking the execution thread.

You will have fewer problems running your application this way, as you will use the same environment that you used during the development process. A lot of bugs can be discovered only when you deploy to a JEE application server (different home dir, classloader issues, library conflicts, etc...).

Please refer to the "'Put your application in production' page":production for more information.

h2. <a name="appservers">Java EE application servers</a>

Your Play application can also run inside your favorite application server. Most application servers are supported out of the box.

h3. Application server compatibility matrix

|| JBoss 4.2.x || JBoss 5.x || JBoss 6M2 || Glassfish v3 || IBM Websphere 6.1 ||IBM Websphere 7 || Geronimo 2.x || Tomcat 6.x || Jetty 7.x || Resin 4.0.5 ||
|| ✓ || ✓ || ✓ || ✓ || ✓ || ✓ || ✓ || ✓ ||  ✓ || ✓  ||                                                                                                                                                            

These application server are known to work with Play but feel free to report any other working deployment.

h3. Deploying

You need to package your application as a WAR file. This is easily done with the following command:

bc. play war myapp -o myapp.war

p(note). Please note that your application server must support deployment of exploded WAR files.

You are now ready to deploy your application.

You are advised to ‘isolate’ your Play application from the other applications to avoid version mismatches between the application libraries. This step is not standardized by the JEE/Servlet specification, and is therefore vendor-specific.

We recommend you refer to your application server manual in order to ‘isolate’ your WAR. As an example below is how you isolate a war file in JBoss Application server. Note that this is an optional step:

Insert the following content (or create the file) in your application war directory at @myapp.war/WEB-INF/jboss-web.xml@:

bc. 
<jboss-web>
 <class-loading java2classloadingcompliance="false">
 <loader-repository>
 com.example:archive=unique-archive-name
 <loader-repository-config>java2ParentDelegation=false</loader-repository-config>
 </loader-repository>
</class-loading>
</jboss-web>

Replace com.example:archive=unique-archive-name with whatever you wish as long as it is unique.            


h3. Datasource

Play also supports Datasource and resource look-up. To use a JNDI Datasource, set the "database configuration":configuration#dbconf as shown below:

bc. db=java:comp/env/jdbc/mydb
jpa.dialect=org.hibernate.dialect.Oracle10gDialect
jpa.ddl=verify

The database plugin detects the pattern @db=java:@ and will de-activate the default JDBC system.


h3. Custom web.xml

Some application servers, such as IBM Websphere, require you to declare a datasource in a @resource-ref@ element in the Servlet API’s @web.xml@ configuration file. By default, @web.xml@ is a file that is generated by Play when you execute the @play war@ command. To customise the generated @web.xml@, generate the exploded WAR version, then copy the generated @web.xml@ file to the @war/WEB-INF@ folder in your application. The next time you will execute the @play war@ command, it will copy your custom @web.xml@ from to the generated folder.

For instance, to declare a datasource for IBM Websphere 7, we can declare a @resource-ref@ in our @war/WEB-INF/web.xml@ file:

bc. <?xml version="1.0" ?>
<web-app xmlns="http://java.sun.com/xml/ns/j2ee"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"
        version="2.4">
  <display-name>Play! (%APPLICATION_NAME%)</display-name>
  <context-param>
    <param-name>play.id</param-name>
    <param-value>%PLAY_ID%</param-value>
  </context-param>
  <listener>
      <listener-class>play.server.ServletWrapper</listener-class>
  </listener>
  <servlet>
    <servlet-name>play</servlet-name>
    <servlet-class>play.server.ServletWrapper</servlet-class>	
  </servlet>
  <servlet-mapping>
    <servlet-name>play</servlet-name>
    <url-pattern>/</url-pattern>
  </servlet-mapping>
  <resource-ref>
        <description>Play Datasource for testDatasource</description>
        <res-ref-name>jdbc/mydb</res-ref-name>
        <res-type>javax.sql.DataSource</res-type>
        <res-auth>Container</res-auth>
  </resource-ref>
</web-app>

h2. <a name="heroku">Heroku - Cloud Application Platform</a>

To run your Play application on the Cloud with Heroku, follow these steps:

1. Install the heroku command line client on "Linux":http://toolbelt.herokuapp.com/linux/readme, "Mac":http://toolbelt.herokuapp.com/osx/download, or "Windows":http://toolbelt.herokuapp.com/windows/download.
2. Install "git":http://git-scm.com/ and setup your SSH key
3. Create an account on "Heroku.com":http://heroku.com/signup
4. Login to Heroku from the command line:

bc. heroku auth:login

5. Create a git repo:

bc. git init

6. Create a @.gitignore@ file containing the following content:

bc. /tmp
/modules
/lib
/test-result
/logs

7. Add the files to the git repo and commit them:

bc. git add .
git commit -m init

8. Create a new app on Heroku:

bc. heroku create -s cedar

9. Push the app to Heroku:

bc. git push heroku master

10. Open the app in your browser:

bc. heroku open


To view the logs run:

bc. heroku logs

To scale the application to multiple dynos run:

bc. heroku scale web=2


To use the "Heroku Shared Database":http://devcenter.heroku.com/articles/database in production add the following to your @conf/application.conf@ file:

bc. %prod.db=${DATABASE_URL}
%prod.jpa.dialect=org.hibernate.dialect.PostgreSQLDialect
%prod.jpa.ddl=update


Learn more in the "Heroku Dev Center":http://devcenter.heroku.com.


h2. <a name="gae">Google Application Engine (GAE)</a>

A Play application can very easily be deployed to the GAE. It is a matter of installing the relevant "GAE module.":http://playframework.org/modules/gae

bc. play install gae

Deploying to the Google Application Engine is again really easy:

bc. play gae:deploy myapp

Refer to the "module documentation":http://playframework.org/modules/gae-1.0.2/home for more information.

h2. <a name="stax">Stax cloud hosting platform</a>

Easy deployment to the "Stax cloud hosting platform":http://www.stax.net: again nothing could be easier. Install the Stax module and deploy within seconds.

Refer to the "module documentation":http://www.playframework.org/modules/stax-1.0.1/home for more information.

<?xml version='1.0' encoding='utf-8' ?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/></head><body><h1 id="TheQuickManualofJapidEnginewithPlayFramework">The Quick Manual of Japid Engine with Play Framework</h1><p>V0.9.10</p><p>Bing Ran&lt;bing.ran@gmail.com&gt;</p><h4 id="Reference">Reference</h4><p><a href="https://github.com/branaway/Japid/wiki/Japid-Generic-Template-Engine-Guide">Use Japid as a Generic Template Engine</a></p><h2 id="Introduction">Introduction</h2><p>Japid is a Java-based statically typed text rendering templates system that aims to deliver the best possible performance.</p><p>It&#8217;s a generic template engine that can be used by any Java applications to render any Java objects. It also provides adapters specifically for the Play! Framework. </p><p>The main goal of Japid is for use in large, high-traffic and highly dynamic Play! bases web applications. To reach that goal, Japid transforms templates files to clean Java source code so that the rendering can run at the raw Java speed. </p><p>Due to its fast performance and low memory usage, Japid is a very good rendering system for Play applications targeting the Google App Engine runtime, which is very resource-constrained. </p><p>The high-performance does not come at the cost of advanced features such as page composition, tags, template inheritance, content caching, and server-side include.</p><p>This document focuses on using the Japid module for the Play! Framework. </p><h2 id="TheDesignphilosophy">The Design philosophy</h2><p>I want:</p><ul><li>this template engine to have clean and practical syntax </li><li>the templates to be <strong>strongly typed</strong>: all variables rendered in a template must be clearly declared as in a Java method. Developers get all the benefits of the strong typing: compile-time error checking, performance at runtime, being debuggable, etc. </li><li>to use Java as the flow control and expression language. Any java classes and features can be very easily used in the templates. </li><li>the best possible performance out of Java. </li><li>it to be versatile to generate any text output and particular not limited to xml/xhtml content.</li><li>to use right amount of convention over configuration.</li></ul><p>I don&#8217;t want:</p><ul><li>it to be XHTML well-formatted, since the tool is used to generate potentially any text.</li><li>it to depend on any other languages such as Groovy.</li></ul><h2 id="Mechanism">Mechanism</h2><p>There are two ways Japid can be integrated with Play 1.2.x and later. In the classic way, Japid is participates in Play&#8217;s class loading and reloading process. All the controllers, models and Japid views are managed by the same Play&#8217;s class loader. This integration mechanism is called &#8220;pre-controller integration&#8221;. Since version 0.9.10, Japid provides it&#8217;s own class loading mechanism that is decoupled from Play&#8217;s class loading. Since the class-loading does not take place until the controllers pass control to the Japid view layer, the newer mechanism is called &#8220;post-controller integration&#8221;. </p><h3 id="PreControllerIntegration">Pre-Controller Integration</h3><ul><li>Japid engine is wrapped as a Play! module which must be configured in the <strong>application.conf</strong> file or the <strong>dependencies.yml</strong> file in the <strong>conf</strong> folder. </li><li>Japid Templates are transformed to Java source files, automatically in a running Play! instance in <strong>DEV (development)</strong> mode, which then are picked up by the Play! runtime in the code change detection process. </li><li>The Java classes that encapsulate all the layout logic can be invoked as plain java classes to generate text output, or they can be used reflectively with conventions in naming and location.  </li><li>A few command-line tools are also provided to generate Java source files from the templates. </li><li>Master layouts are translated to abstract super classes, which is to be inherited by views. </li></ul><h3 id="PostControllerIntegration">Post-Controller Integration</h3><p>In this mode, </p><ul><li>Technically Japid engine does not need to be configured to a Play&#8217;s instance. It is used in a way that&#8217;s very similar to how rendering engines such as Velocity and Freemarker are used in web applications. </li><li>Japid is a simple, self managing layer that sits after the controllers. Japid manages its own template compiling to Java classes and class loading. </li><li>File change detection and class reloading takes place after the code in the controller has been executed.   </li><li>The Java intermediaries are not supposed to be invoked directly from within the controllers. They are wrapped in a special controller super class named &#8220;JapidController2&#8221;. </li></ul><p>The post-controller Japid decouples the view layer from the controller and model layer at class loading level. It further avoids cross interference when hot swapping new code in DEV mode. This can translate to further time saving in quickly making changes in DEV mode. </p><p>Another great advantage in using this model is that errors in compiling or running Japid views will be picked up by the Play&#8217;s nice error displaying page, another great debugging tool and time saver. </p><h2 id="JapidModule">Japid Module</h2><p>First you need to get yourself familiar with the &#8220;Play! module concept&#8221;:</p><p>- http://www.playframework.org/documentation/1.2.2/modules <br/>- http://www.playframework.org/documentation/1.2.2/dependency</p><p>The following is a sample session. </p><p>To show all the version of Japid module, from the command-line:</p><p><pre><br/>$ play list-modules<br/></pre></p><p>And the section for Japid is like:</p><p><pre><br/>~ [japid]<br/>~   Japid template engine<br/>~   http://www.playframework.org/modules/japid<br/>~   Versions: 0.2, 0.3.1, 0.5.1, 0.9.0, head<br/></pre></p><p>Then you can pick the version to install, usually the head version, which is also the default version. </p><p>To install the Japid module:</p><p><pre><br/>$ play install japid-0.9.10<br/></pre></p><p>or, </p><p><pre><br/>$ play install japid-head<br/></pre></p><p>or simply:</p><p><pre><br/>$ play install japid<br/></pre></p><p>to get the default version. </p><p>The module goes to the <code>modules</code> directory of the Play!'s installation root. The module contains </p><ol><li>the module jars in the <code>lib</code> directory</li><li>the Eclipse plugin in <code>the eclipse-plugin</code></li><li>a sample Japid application in the <code>JapidSample</code> </li><li>the source code in the <code>src...</code> directories</li></ol><p>Now add a reference to Japid module in the <code>application.conf</code> file in your application:</p><p><pre><br/>module.japid=${play.path}/modules/japid-0.9.10  // or whatever the version number is<br/></pre></p><p>Since some versions ago, it&#8217;s recommended that developers use <strong>dependencies.yml</strong> to configure modules or &#8220;dependencies&#8221;. In case of Japid, add this line to the dependencies file:</p><p><pre><br/>    - play -&gt; japid 0.9.10<br/></pre></p><p>The next thing to do is to create the default directory structure required by Japid, if you want to use the &#8220;pre-controller integration&#8221; model. From the app root:</p><p><pre><br/>$ play japid:gen<br/></pre></p><p>The <code>japidviews</code> tree is now created in the <code>app</code> directory</p><p>If you&#8217;re using the so called &#8220;post-controller integration&#8221; model, do nothing at this stage.  </p><p>Now you&#8217;re ready to code your models, controllers and Japid views! Every time you add a new controller you can <code>play japid:gen</code> to create a new sub-directory to match the controller or you can create the directory manually if you&#8217;re confident about your typing skill. </p><h2 id="RuntimeDirectoryStructureofJapidinPlayapplications">Runtime Directory Structure of Japid in Play! applications</h2><h3 id="PreControllerIntagration">Pre-Controller Intagration</h3><p>All template files are located in <code>app/japidviews</code> directory tree, as illustrated here:</p><p><pre></p><p>/app/controllers/ControllerA.java<br/>                /more/ControllerB.java<br/>    /japidviews/_javatags/<br/>               /_layouts/<br/>               /_notifiers/<br/>               /_tags/<br/>               /ControllerA/action1.html<br/>                           /action1.java<br/>               /more/ControllerB/action1.html<br/>                                /action1.java</p><p></pre></p><p>Notes:</p><ol><li>the <code>_javatags</code> sub-directory contains any Java code you want to use in your templates. Any java classes defined in the japidviews/_javatags will be imported in the generated template java code. Any static members will be imported too. There used to be a file named  JapidWebUtil in Japid versions earlier than 0.8.6. It is not enforced anymore and is deprecated. </li><li>the <code>_layouts</code> sub-directory contains global layouts that are accessible to all view templates. However as explained below, Japid layouts can be placed anywhere in the tree and can be referenced using the fully qualified name in the templates, just like the way a Java class class is referenced. </li><li>the <code>_tags</code> sub-directory contains global tags that are accessible to all view templates. However as explained below, Japid tags can be place anywhere in the tree and can be referenced using the fully qualified name in the templates, just like the way a Java class class is referenced.</li><li>the <code>_notifiers</code> sub-directory contains email templates coded in Japid. There is a section for this later in this document. </li><li>The other nodes of the tree are created to match the structure of the controller and actions therein. For each controller there is a directory created which contains a bunch of template files named after the action method in the controller. The Japid converter translates the html template files to java files in the same directory. Please note though, the layouts of the template files are required only if we are going to use <strong>implicit template binding</strong>. A template can be placed anywhere in the case of <strong>explicit template invocation</strong>. There is a section of document for this later. </li></ol><h3 id="PostControllerIntegrationJapidFileStructure">Post-Controller Integration Japid File Structure</h3><p>The post-controller japid model assumes a folder named &#8220;japidroot&#8221; as the root of the &#8220;japidviews&#8221; tree. The japidroot is located directly in the application root, rather than the app folder. This means it&#8217;s NOT on the application classpath hence the application&#8217;s class loader does not see any of those Java classes derived from the japid view files. </p><h2 id="JapidSyntax">Japid Syntax</h2><p>The original version of Japid (around version 0.3) copied a lot of the <a href="http://www.playframework.org/documentation/1.1.1/templates">syntax from the Play! framework</a>. The idea was to help the Play! users to pick up the engine quickly. New and simpler syntax has been introduced over the course of one year use in real-world projects. This documents tries to compare the syntax of different flavors. </p><p>For your information, the <a href="http://weblogs.asp.net/scottgu/archive/2010/07/02/introducing-razor.aspx">Microsoft Razor Template Engine</a> is a source of inspiration for some recent syntax improvement, particularly the consolidation of the usage of &#8220;`&#8221;, or &#8220;@&#8221; since version 0.8.4.1.</p><p>Note:</p><p>1. To escape the special markers used in various syntax constructs, please prefix them with the escape sign &#8220;~&#8221;, such as:</p><p><pre><br/>~~ for ~<br/>~@ for @<br/>~$ for $<br/>~% for %<br/>~&amp; for &amp;<br/>~* for *<br/></pre></p><p>2. To join lines, please use a back slash &#8220;\&#8221; immediately followed by a new line. The back slash and the new line symbol will be simply swollen by the parser. </p><p><pre><br/>@ Str\<br/>ing a = "hello\<br/> "; \<br/>String b = &#8220;world&#8221;;<br/>message:\<br/> ${a+b}<br/></pre></p><p>is equal to:</p><p><pre><br/>@ String a = &#8220;hello &#8221;; String b = &#8220;world&#8221;;<br/>message: ${a+b}<br/></pre></p><h3 id="Thedelimiterand">The delimiter: <code>`</code> and <strong>@</strong></h3><p>The delimiter plays a very important role in dynamic templates: </p><ol><li>It starts a <code>directive</code> or <code>command</code>, which is instruction to the code generator to create special Java source code.  </li><li>It starts a line of pure Java code to be placed in the generated code. </li><li>It ends a script line if the line is already started by another `. </li></ol><p>A script line ends with it encounter a <code>new line, i.e., '\n'</code> or another delimiter. </p><p>The Japid parser will first determine if the word following the delimiter is a command name and treat the rest of the line as Java code if it is not. </p><p>Originally the back quote has been selected as the special character, because:</p><ol><li>The back quote is the most left upper key on most keyboard ( except the escape key ) so it&#8217;s easy to remember.</li><li>It&#8217;s not a key combination like the #$%, which requires pressing two keys: the Shift and 3, 4 or 5, and with both hands. I think it&#8217;s easy for even the most untrained fingers. Comparing  `get title` with #{get &#8220;title&#8221;/}, the Japid syntax requires 10 key pressings and the latter requires ~20 key pressings, including all the shift keys.</li><li>The back quote is rare enough in normal text content so it saves all the escapes.</li><li>In most Linux shell, the ` is a very important key that indicates &#8220;command substitution&#8221;: the part inside the quotes will be executed and the result be substituted in the place. I think Japid uses the symbol in exactly the same spirit.</li></ol><p>A little annoying problem with ` is it appears less visible in some fonts, although not an issue for the fixed-width fonts that source code usually is displayed with.</p><p>Since version 0.8.4.1, one can use the &#8216;@&#8217; sign in lieu of the the back quote. In some keyboard layout, the back quote is difficult to access while the &#8220;at&#8221; sign is a lot easier. The result is that both the back quote and the @ sign are valid delimiters, but they cannot be used in the same template file. There is no global configuration to specify which one is the special marker. Instead the system determines the marker file-by-file. This is how the parser determines which delimiter is used in template file:</p><ol><li>It scans the template file for the first occurrence of a line that starts with either the back quote or the at sign and use the character as the Japid delimiter for the specific file.</li><li>If for some reason the marker cannot be determined, the back quote is used as the default. </li><li>To make sure the parser picks up the correct marker, one can add a single line on the top of the document and the single line contains the intended marker to use, like this:</li></ol><p><pre><br/>`<br/>the rest of the file<br/></pre></p><p>or:</p><p><pre><br/>@<br/>the rest of the file<br/></pre></p><p>One of the ramifications is that a project can contain template files and some of them are using the <code>`</code> as the special marker and the others using the @ sign.</p><p>Note: to escape the delimiter, please use a single back quote followed by the delimiter:</p><p><pre><br/>``this is normal text and so is `@<br/></pre></p><p>The rest of this document uses the single back quote(`) as the delimiter in most of the cases. </p><h3 id="ViewsTagsandLayout">Views, Tags and Layout</h3><p>There are three types of templates in the Japid system:</p><ol><li>Views: the templates that play the central role in rendering data. Most of the rendering logic is being carried out here. </li><li>Tags: the templates that encapsulate some logic of data rendering and can be invoked from any other templates. They&#8217;re equivalent to functions. </li><li>Layouts: the templates that handle the out most level of &#8220;layout&#8221; of web pages, such as the arrangement of the headers, footers, side bars, columns etc.</li></ol><p>Views usually <strong>extend</strong> layouts and pass text snippet or variables to the layout to be displayed in designated location in the layout. </p><p>Here is a simple layout template (I have left out irrelevant markups (such as HTML tags) as much as possible make the syntax structure cleaner.):</p><p><strong>master.html</strong></p><p><pre><code><br/>This is the header. </p><p>The title of this article is "`get title`"</p><p>`doLayout</p><p>This is the footer.<br/></code></pre></p><p>A layout can placed anywhere but usually is in the <code>app/japidviews/_layouts</code> directory, which is visible to any views in the project.</p><h3 id="Displayanamedtextvaluegettextblockname">Display a named text value: <code>`get &lt;text block name&gt;</code></h3><p><code>`get title`</code> is to retrieve a text block named &#8220;title&#8221;, to be passed from any child views that inherited from this layout. The second ` can be left out if there is no more meaningful letters in the rest of the line. </p><p>A <code>`get xxx</code> command is usually matched by a <code>`set xxx</code> command in the views that inherit from this layout. The <code>set</code> command assigns a string to the variable <code>xxx</code>. If the variable is not set by the child view, an empty string is returned. Note: older version of Japid requires each variable referenced by <code>get</code> must be <code>set</code> in the child. Japid 0.6.2 and up makes it optional.</p><table style="border:1px solid black; cellpadding: 1px"><tr><th>Japid syntax</th><th>Play! syntax</th></tr><tr><td><code>`get &lt;text block name&gt;`</code></td><td><code>#{get "title"/}</code></td></tr></table><h3 id="InvoketheChildLayoutdoLayout">Invoke the Child Layout: <code>`doLayout</code></h3><p>This command is to let the child template to render itself and substitute the command with the result. This command is pretty much the marker of templates of <code>layout</code> type.</p><table style="border: 1px dashed gray; cellpadding: 1px"><tr><th>Japid syntax</th><th>Play! syntax</th></tr><tr><td><code>`doLayout`</code></td><td><code>#{doLayout/}</code></td></tr></table><p>Once we have the layout we are ready to code the main view template. </p><p><strong>user.html</strong></p><p><pre><code><br/>`import models.mymodels.User<br/>`extends master<br/>`args User user, int count<br/>`set title:"The User Detail"</p><p>`if count<br/>    `for (int i &gt; 0; i &lt; count; i++) {<br/>        hello $user.name, and you are `tag showAge user.age`.<br/>    `}<br/>`<br/></code></pre></p><p>There are a few new syntax here:</p><h3 id="ImportJavaClassestoTemplatesimport">Import Java Classes to Templates: <code>`import</code> </h3><p>Purpose: same as in java.  </p><table style="border: 1px dashed gray; cellpadding: 1px"><tr><th>Japid syntax</th><th>Play! syntax</th></tr><tr><td><code>`import x.y.z</code>, <code>`import static x.y.Z.*</code> </td><td>none</td></tr></table><p>Note: </p><ol><li>there is no ending `.</li><li>the ending ; is optional</li><li>one line per import</li></ol><h3 id="SpecifytheLayoutforaTemplateextends">Specify the Layout for a Template: <code>`extends</code> </h3><p>Purpose: same as in java. The super class is usually a layout template. The template name can be:</p><ol><li>the short file name: <code>master.html</code>, or preferrably without the extension: <code>master</code>. The file must be either in the same directory or in the <code>app/japidviews/_layouts</code> directory.   </li><li>the file in full path: <code>japidviews.mypackage.master</code>  </li><li>a file in a sub directory, using a leading &#8220;.&#8221;: <code>.sub.master</code>  </li></ol><p>Note: </p><ul><li>there is no ending `.</li><li>starting from version 0.7, the layout can take parameters right from the <code>extends</code> directive, as in</li></ul><p><pre><br/>`args String a, int b<br/>`extends aLayout(a, b +1)<br/></pre></p><p>Of course the layout must declare to accept the arguments with the <code>`args</code> directive.</p><p>The classic syntax style is still supported:</p><p><code>#{extends "mater.html"/}</code></p><p>Please note: you should use double quotes to enclose the layout name in the &#8220;classic&#8221; Japid style. The profuse use of single quote in Play!'s templates are mostly replaced with double quotes in Japid&#8217;s classic style to better match Java syntax. Some Japid&#8217;s recent syntax goes even further to remove those quotes.  </p><h3 id="SpecifytheDataObjectstoRenderargsor">Specify the Data Objects to Render: <code>`args</code>, or <code>`()</code></h3><p>Purpose: the parameters to be passed to this template to render. The format is the same as in Java method declaration. </p><p>Note: </p><ol><li>some people may find the <code>`()</code> more expressive than the <code>`args</code> syntax, but they&#8217;re functionally identical: <code>`(String a, Integer b)</code> === <code>`args String a, Integer b</code>. </li><li>Data to be rendered must (almost) be declared passed to the templates via the <code>`args</code> directive. However There are a few Play! specific data that are implicitly available, as explained later in this document.</li><li>The data type must be visible, meaning it must be imported. However there are several classes and packaged that are imported to any templates by default:</li></ol><p><pre><br/>import java.util.*;<br/>import java.io.*;<br/>import cn.bran.japid.tags.Each;<br/>import static play.templates.JavaExtensions.*;<br/>import static cn.bran.play.JapidPlayAdapter.*;<br/>import static play.data.validation.Validation.*;</p><p>import japidviews._layouts.*;<br/>import japidviews._tags.*;<br/>import japidviews._javatags.*;<br/>import models.*;<br/>import controllers.*;</p><p>import play.data.validation.Validation;<br/>import play.mvc.Scope.*;<br/>import play.data.validation.Error;<br/>import play.mvc.Http.*;<br/></pre></p><p>Note: One advantage of using `() is it can span multiple lines, useful when the argument list is long. Of course you can use the <code>`args</code> and the line continuator &#8220;\&#8221; to simulate multi-line argument list too. </p><p><pre><br/><strong>{here I&#8217;m using the alternate marker @ instead of the default `}</strong><br/>@(<br/>    my.Object o,<br/>    int i,<br/>    String s<br/>)<br/></pre></p><p>Since 0.8.8, template parameter can be annotated with a default value for use with <code>tag invocations with named arguments</code>. E.g.:</p><p><pre><br/>    `args String msg, @Default(new String(&#8220;m2message&#8221;))String m2, Integer age<br/></pre>        </p><p>or:</p><p><pre><br/>`(<br/>    @Default(&#8220;message 1 default value&#8221;) String msg, <br/>    @Default(new String(&#8220;m2message&#8221;)) String m2, <br/>    @Default(20) Integer age<br/>)<br/></pre>        </p><p>Note: </p><p>1. due to parser limitation, there cannot be a new-line between the annotation and the parameter type.<br/>2. It&#8217;s <code>Default</code>, not <code>default</code>. </p><h3 id="Createanamedtextblockset">Create a named text block: <code>`set</code></h3><p><strong>Purpose</strong>: to assign a text block to a name, which can be retrieved in the layout of the current view. </p><p>There are two forms of <code>set</code>:</p><ol><li>one-liner: <code>`set title:"some value"</code>. The double quotes are required. </li><li>block form: </li></ol><p><pre><br/>`set title<br/>  a very long and funny title, a very long and funny title<br/>  a very long and funny title<br/>`<br/></pre></p><p>Notes:</p><ol><li>The <code>set</code> command is location-insensitive, meaning they can be placed anywhere in a template and won&#8217;t interfere with the main text flow.</li><li>There can be multiple <code>set</code> commands in a template, each of which should define a different text block.</li><li>Limitations:<ol><li>If there is any reference to variables in the text block, those variables must be 1) listed in the <code>`args</code> directive; or 2) defined within the <code>set</code> block.</li><li>Tags cannot be referenced in a <code>set</code> command. This limitation will be lifted in the future. </li></ol></li></ol><h3 id="ConditionStatementif">Condition Statement <code>`if</code> </h3><p>First of all you can use the plain Java if-else-statement:</p><p><pre><br/>`if (cond) {<br/>    xxx<br/>`} else if (cond2){<br/>    yyy<br/>`} else {<br/>    zzz<br/>`}<br/></pre></p><p>The <code>cond</code> and <code>conds</code> must be boolean values. This sometimes forces people to write tedious code like this:</p><p><pre><br/>`if (aString != null &amp;&amp; aString.length() &gt; 0) {<br/>    xxx<br/>`}<br/></pre></p><p>The Japid template base class has a method <code>asBoolean(Object)</code> that takes any object and infers a boolean value from it to any templates it generates. So you can improve the above a little bit:</p><p><pre><br/>`if (asBoolean(any_java_expression)) {<br/>    xxx<br/>`}<br/></pre></p><p>The <code>asBoolean</code> returns <code>true</code> if the argument is</p><ol><li>none-empty string.</li><li>a collection that has at least one element.</li><li>an integer or long value that is not zero.</li><li>an array that has at least one element. </li><li>an object that is not null.</li></ol><p>But some people really like the <code>if</code> to be smarter. So I have decided to enhance the <code>if</code> statement syntax to add some smartness to it, like in Groovy:</p><p><pre><br/>`if expr1 {<br/>    xxx<br/>`} else if expr2 {<br/>    yyy<br/>`} else {<br/>    zzz<br/>`}<br/></pre></p><p>Basically the new syntax opens up the parenthesis to take any Java expressions and plays clever with it. The compiler translates the above code to:</p><p><pre><br/>`if (asBoolean(cond)) {<br/>    xxx<br/>`} else if (asBoolean(cond2)) {<br/>    yyy<br/>`} else {<br/>    zzz<br/>`}<br/></pre></p><p>But wait, you can go one more step further and get rid of the curly braces. Yes you can:</p><p><pre><br/>`if expr1<br/>    xxx<br/>`else if expr2<br/>    yyy<br/>`else<br/>    zzz<br/>`<br/></pre></p><p>Remember to use a ` to close the if-else statement.</p><p>What if you want to negate the condition? Use &#8220;!&#8221; of course.</p><p><pre><br/>`if ! expr1<br/>    xxx<br/>`else if ! expr2<br/>    yyy<br/>`else<br/>    zzz<br/>`<br/></pre></p><p>In summary,  </p><ol><li>if you wrap the expression in &#8220;()&#8221;, you must use the full Java syntax. The expression must be of a boolean type, otherwise it can be any data type. But check the conversion rule listed above and see if the outcome is what you&#8217;re looking for.</li><li>If you use &#8220;{}&#8221;, you must them all the way through. You cannot mix them u</code></pre></li></ol><p>You get the idea. </p><p>BTW, in case you want to write the if-else statement in one line, you can do it this way:</p><p><code>`if xxx` foo `else` bar `</code></p><p>What happens here is that each of the single back quote switches the current mode between <code>script mode</code> and <code>plain text mode</code>. The above line has odd number of ` therefore it&#8217;s still in script mode. However since the &#8220;\n&#8221; character always changes the current mode to plain text mode, the next line will be in plain text mode. If you have more text to display, you&#8217;ll need to add another ` like this:</p><p><code>`if xxx` foo `else` bar ` `more text to display</code></p><p>Note that I don&#8217;t use two consecutive back quotes. The reason is <code>``</code> is treated as a escape sequence for a <code>`</code> literal. </p><h3 id="Iterateovercollectionsarraysfor">Iterate over collections, arrays: <code>`for</code> </h3><p>Actually this is the plain Java way of iterating through Java collections and arrays. The word &#8220;for&#8221; is not a special word in the Japid templates. It&#8217;s pure Java code started by a back quote. Looping in Japid is Java as usual, including the closing brace.</p><p><pre><br/>`for (int i = 0; i &lt; count; i++) {<br/>    whatever you put here. ${i}<br/>`}<br/></pre></p><p>or, </p><p><pre><br/>`String[] names = ...;</p><p>`for (String name: names ) {<br/>    whatever you put here. ${name}<br/>`}<br/></pre></p><p>Starting from version 0.7.1, the <code>for</code> has an &#8220;open&#8221; form that gives template authors access to a few implicit variables related to the loo</code></pre>The variables are explained in the following section, but here is the syntax, basically you leave out the &#8220;()&#8221; and the "{}"</p><p><pre><br/>`String[] names = ...;</p><p>`for String name: names </p>   Your name is: $name,
    the total size: $_size,
    the current item index: $_index,
    is odd line? $_isOdd
    is first? $_isFirst
    is last? $_isLast<p>`<br/></pre></p><p>Notes:</p><ul><li>Since this form involves multiple method dispatching, it&#8217;s slower than the raw <code>for</code> loop. But the difference is in micro-second scale and probably does not matter. </li><li>you cannot use &#8220;{}&#8221; with the &#8220;open for loop&#8221;. This is <strong>invalid</strong>:</li></ul><p><pre><br/>`for String name: names { <br/>    xxx<br/>`}<br/></pre></p><ul><li>there is <code>_isOdd</code> but there is no <code>_isEven</code></li><li><code>continue</code> does not in open for loops, neither does <code>break</code></li></ul><h3 id="Enhancedloopingeach">Enhanced looping: <code>`each</code></h3><p>Note: it&#8217;s been deprecated in favor of the the &#8220;open for&#8221; format. </p><p>The <code>each</code> command creates a loop construct that makes available additional looping attributes for the template authors to fine-tune the data rendering. For an example:</p><p><pre><br/>`each names | String name<br/>    $name, $_size, $_index, $_parity $_isOdd $_isFirst $_isLast <br/>`<br/></pre></p><p>Note:</p><ol><li>The <code>each</code> block ends with a single ` sign on a whole new line.</li><li>In fact the above syntax is a standard way to invoke a <code>tag</code> with a <code>callback body</code>. See later in <code>tag</code> invocation. </li><li>The variable <code>names</code> is the collection to iterate on. It can be of any of the following Java type:<ol><li>Collection</li><li>Iterator, in which case the _size property cannot be determined before hand and is given a value of -1.</li><li>Iterable, in which case the _size property cannot be determined before hand and is given a value of -1.</li><li>array of anything</li></ol></li><li>The construct after the vertical line is the declaration of the instance variable for each round of iteration. The data type must present before the variable name. In the body of each we see a bunch of additional variables related to the current iteration:</li></ol><table style="border: 1px dashed gray; cellspacing: 2px"><tr><th>Variable</th><th>Meaning</th></tr><tr><td style="border:1px grey solid">int _size</td><td>the size of the collection or array, -1 if not determined in the case of iterable as the collection</td></tr><tr><td style="border:1px grey solid">int _index</td><td>the index of the current instance in the collection </td></tr><tr><td style="border:1px grey solid">boolean _isOdd</td><td>true if the index is odd, false if it is even</td></tr><tr><td style="border:1px grey solid">String _parity </td><td>&#8220;odd&#8221; for the odd lines, &#8220;even&#8221; for the even lines</td></tr><tr><td style="border:1px grey solid">boolean _isFirst </td><td>true if the current instance is the first in the collection</td></tr><tr><td style="border:1px grey solid">boolean _isLast</td><td>true if the current line is the last in the collection</td></tr></table><h3 id="JavaExpressionexpressionandexpression">Java Expression: <code>${expression}</code> and <code>~{expression}</code></h3><p>The string value of a <code>Java expression</code> can be interpolated in text stream using the ${} syntax, as is used in Play&#8217;s Groovy based templates. The {} signs can be omitted if doing so won&#8217;t make the expression fuse with the rest of the context thus cause confusion to the compiler (or your eyes). For examples:</p><p><pre><br/>${user.name} == $user.name<br/>${user.name.length()} == $user.name.length()</p><p>Japid parser is greedy in matching the Java expression:</p><p>$user.age + 10! == ${user.age + 10}!</p><p></pre></p><p>Japid parser uses greedy logic to find the end of $ expressions without the {} pair:</p><p><code>It searches back from the end of the current line and matches the longest possible valid Java expression.</code></p><p>Note: the <code>${}</code> notation does <strong>not</strong> escape the string value of expressions to make it HTML safe, like what Play! does. One can simply do:</p><p><code>${escape(expr)}</code></p><p>to get the effect. The <code>escape()</code> is a static method defined in <code>play.templates.JavaExtensions</code> class in Play!, which is automatically imported to any Japid templates. There are other useful static methods in that class that are available directly in the templates. See <a href="http://www.playframework.org/documentation/1.1/javaextensions">JavaExtension</a>. </p><p>Another way to make the string value of expressions HTML safe is to take advantage of the <code>escaped expression notation</code>, i.e., the <code>~{}</code> notation.</p><p>The <code>~{}</code> does exactly the same as the <code>${escape(...)}</code>. So if you are not concerned about the slight performance penalty caused by the <code>escape</code> method call, you can safely use the <code>~{}</code> notation as the safe expression throughout the entire application and forget about <code>${}</code>.</p><p>BTW, <code>~expr</code> also works.</p><p>New! the <strong>Elvis operator</strong>: <code>?:</code>. </p><p>Quoted from the Groovy online documentation: </p><blockquote><p>The &#8220;Elvis operator&#8221; is a shortening of Java&#8217;s ternary operator. One instance of where this is handy is for returning a &#8216;sensible default&#8217; value if an expression resolves to false or null.</p></blockquote><p>Well it&#8217;s not exactly that I have implemented the Elvis in Java:) What I have added is the <code>?:</code> combination that works <strong>only</strong> inside of <code>${}</code> expressions. An example:</p><p><pre><code><br/>`args String name, Address addr</p><p>The name is ${name ?: &#8220;empty&#8221;}<br/>The street number is ${addr.streetNo ?: &#8220;not present&#8221;}<br/></code></pre></p><p>Here is what will happen: </p><blockquote><p>If the evaluation of the Java expression before the Elvis operator results in an empty string or an NPE is thrown during the evaluation, the default string value is displayed. </p></blockquote><p>You can use "" as the default string, which effectively achieve &#8220;safe bean property navigation&#8221;: <code>${my.fancy.expr ?: ""}</code>.</p><p>Imagine what you have to do if without using this handy operator? Perhaps something like this:</p><p><pre><br/>`args String name</p><p>The name is: `if name` $name `else` empty! ` <br/></pre></p><p>This is a lot eye-stressing if you ask me. </p><p>Of course you can use the Elvis operator with the escaped expression notation: <code>~{}</code>. </p><h3 id="SafePropertyNavigationsupressNullon">Safe Property Navigation: <code>`supressNull on</code></h3><p>An expression like <code>$user.name.length()</code> can cause potential problems if any of the nested properties is null, in which case the template will throw NPE. There is a so called <code>safe navigation operator</code> in Groovy: <code>p?.p2?.p3</code>. Java does not have this. Instead Japid introduces a directive to suppress the NPE in property navigation.</p><p><pre><br/>` suppressNull on</p><p>` String a = &#8220;a&#8221;;<br/>safe to do $a.length()</p><p>` a = null;<br/>also safe to do a.something too: $a.length()<br/></pre></p><p>The second <code>$a.length()</code> in the above sample throws an NPE, which is caught by the template and discarded with the <code>`suppressNull on</code> directive at the top of the script. what you end up with is an empty string "";</p><p>Note: only NPEs thrown after the directive will be suppressed. </p><p>Again, you might find the <strong>Elvis</strong> operator &#8220;?:&#8221; a lot more flexible in dealing with nulls and empty variables.</p><h3 id="SimpleTagInvocationtagtagNamearg1arg2...">Simple Tag Invocation: <code>`tag tagName arg1, arg2...`</code></h3><p>Back to the view template:</p><p><strong>user.html</strong></p><p><pre><code><br/>@import models.mymodels.User<br/>@extends master<br/>@(User user, int count)</p><p>@for (int i &gt; 0; i &lt; count; i++) {<br/>    hello $user.name, and you are @tag showAge user.age @.<br/>@}<br/></code></pre></p><p>In the body of the for loop we are invoking a <code>tag</code> named <code>showAge</code>. Think of a tag as a function defined in a separate file. Here is the tag file:</p><p><strong>showAge.html</strong></p><p><pre><code><br/>@(int age)<br/>you are $age years old<br/></code></pre></p><p>The above tag simply takes an <code>int</code> as the age and append &#8220;years old&#8221; to it. </p><p>The tag invocation has an alternative: </p><p><code>`tag tagName(arg1, arg2...)`</code></p><p>which looks more like function calls.</p><p>And the <code>`tag</code> command can be further shorten to <code>`t</code>, as in:</p><p><code>`t tagName(arg1, arg2...)`</code></p><p>Note: the closing <code>`</code> can be omitted if there is no other letters in the rest of the current line, because a new-line character is a valid tag closing symbol.</p><p>Since version 0.8.5, Japid also supports invoking tags with <code>named arguments</code>: </p><p><code>`t tagName(argName1=arg1, argName2=arg2...)`</code></p><p>The caller side does not need to provides arguments for all the parameters. The missing ones default to null or default primitive values as defined by the Java specification.  </p><p>Note: you cannot mix these two conventions. You either use arguments without any name prefix or all the arguments must use the named format. </p><h4 id="locatingatagfile">locating a tag file</h4><p>Similar to locating a layout file, the tag name can take a few forms:</p><ol><li>a simple name: <code>tagName</code>, which can be either in the same directory as the current template file, or in the <code>japidviews._tags</code> directory.</li><li>a full package form: <code>japidviews.my.pack.tagName</code>, or</li><li>a relative form: <code>.sub.tagName</code>, which is located in a sub directory of the current directory. </li></ol><p>Also please note that one can use &#8220;/&#8221; in lieu of &#8220;.&#8221; but I prefer the dot syntax. </p><p>The default Play! templates assume that all tags are located in the <code>app/views/tags</code> directory, just like the layouts which are assumed to be in the <code>app/views</code>. It will get too crowded when projects get bigger. Japid gives authors the flexibility to organize the layouts and tags in the whatever way the authors see fit, e.g., in the same directory as the view templates or sub-directories of it. </p><h3 id="AdvancedTagInvocationtagtagNamearg1arg2...type1arg1type2arg2">Advanced Tag Invocation: <code>`tag tagName arg1, arg2... | type1 arg1, type2 arg2`</code></h3><p>A tag can take a block of template text as the last argument. For an example:</p><p><pre><br/>`tag fancyTag &#8220;hello&#8221; | String name<br/>    what a fancy name: ${name}!<br/>`<br/></pre></p><p>There are two arguments to the tag invocation:</p><ol><li><code>"hello"</code>, a String, and</li><li><code>String name \n what a fancy name: $name</code>, a template. </li></ol><p>The vertical line &#8220;|&#8221; separates the regular arguments and the template block. Note: the Japid parser requires the presence of this separator even if the template body does not have any parameters. </p><p>This is valid:</p><p><pre><br/>`tag fancyTag &#8220;hello&#8221; | <br/>    what a fancy name!<br/>`<br/></pre></p><p>And this is not:</p><p><pre><br/>`tag fancyTag "hello"<br/>    what a fancy name!<br/>`<br/></pre></p><p>The reason is that a new-line character &#8216;\n&#8217; is a tag terminator if the parser does not detect any a &#8220;|&#8221; in the argument list. The &#8220;|&#8221; tells the parser that a template block is following the current line. </p><p>The template parameters passed to a tag are rendered by a <code>`doBody arg1, arg2...</code> command in the tag file, as explained in the <strong>Tag Definition</strong> later in this document. Or one can use the <code>renderBody(...)</code> to get the result as a String in the template.</p><p>Note: the callback template block is optional and can be left out, such as:</p><p><pre><br/>`tag fancyTag "hello"<br/></pre></p><p>In the above invocation, the doBody in the fancyTag has no effect.</p><h3 id="Tagdefinitions">Tag definitions</h3><p>Any views can be used as tags. The above mentioned view file:</p><p><strong>user.html</strong></p><p><pre><code><br/>`import models.mymodels.User<br/>`extends master<br/>`args User user, int count</p><p>`for (int i &gt; 0; i &lt; count; i++) {<br/>    hello $user.name, and you are `tag showAge user.age`.<br/>`}<br/></code></pre></p><p>can be invoked from other views. e.g.,</p><p><strong>another view</strong></p><p><pre><code><br/>` User aUser = ...;<br/>`tag user(aUser, 10)<br/></code></pre></p><p>In another word, regular views can be invoked either from the controller actions or from other views. </p><p>However, the regular views cannot take a template as an argument, unless it contains a special tag: <code>`doBody</code>, as in:</p><p><strong>fancyTag.html</strong></p><p><pre><code><br/>`args String m</p><p><p>I got $m, and the body is:</p><br/><p><br/>`doBody m<br/></p><br/><p>done.</p><br/></code></pre></p><p>Note: the argument list of the <code>`doBody</code> command must match that declared after the &#8220;|&#8221; symbol in the invoking templates. </p><p>The <code>doBody</code> command passes matching arguments to the passed-in template. This behavior is sometimes referred to as &#8220;call-back&#8221;.</p><p>With some imagination, a tag can be effectively used as a layout to a view. The layout part is done in the tag and the main template section is passed in as the last argument of the tag invocation.  </p><p>Note:</p><ol><li>Tags can invoke other tags. </li><li>Tags usually don&#8217;t inherit from layouts. </li><li>Tags can be placed anywhere in the <code>japidviews</code> tree. </li></ol><p>New feature since 0.8.9.4: sometimes authors may want to store the doBody result in a local String variable. One can acheive that using a special operator &#8220;-&gt;&#8221;, the pointer operator as in C, after the doBody callback. E.g.:</p><p><pre><br/>`doBody &#8220;hello&#8221;, 123 -&gt; body<br/>`// now a new variable named body of type String is defined in the current scope<br/><p>Before body</p><br/>$body<br/><p>After body</p><br/></pre></p><h3 id="Usetagstoincludestaticcontent">Use tags to include static content</h3><p>Some other template engines provides &#8220;include&#8221; directive to include static content in the templates. In Japid a tag without any parameters is effectively static content that can be &#8220;included&#8221; in other templates by the normal tag invocation syntax:</p><p><pre><br/>`t header<br/>...<br/>`t footer<br/>`t disclaimer<br/></pre></p><p>So basically you throw the static content in the same directory where the main templates reside, or simply in the <code>_tags</code> directory, and invoke it with <code>`t</code>, then effectively you get static include. </p><h3 id="Verbatimtextverbatim">Verbatim text: <code>`verbatim</code></h3><p>Purpose: to display a block of text un-parsed by Japid. </p><p><pre><br/>`verbatim<br/>    OK, anything inside this block is not parsed: `command, ${expression}, etc<br/>`<br/></pre></p><p>Note: a <code>verbatim</code> block must be closed by a standalone back quote that occupies a whole line.</p><table style="border: 1px dashed gray; cellspacing: 2px"><tr><th>Japid</th><th>Play!</th></tr><tr><td style="border:1px grey solid"><code>`verbatim ....  \n`</code></td><td> #{verbatim}... {/}</td></tr></table><h3 id="MoreaboutPassingDatatotheLayouts">More about Passing Data to the Layouts</h3><p>Previously I have explained how to use the <code>'set</code> command to create a named text value and use the <code>`get</code> in the layout to place the value in the output. </p><p>There are two other ways to pass data from the child templates to the layouts. </p><h4 id="PassingdataintheextendsDirectivenewinJapidv0.7">Passing data in the <code>`extends</code> Directive (new in Japid v0.7)</h4><p>The <code>extends</code> directive allows passing objects to the layout in this way:</p><p><strong>child template</strong></p><p><pre><br/>`args String a<br/>`extends myLayout(a, 123, &#8220;home&#8221;)</p><p></pre></p><p><strong>The layout</strong></p><p><pre><br/>`args String a, int b, String c<br/>do whatever with them<br/></pre></p><p>Smells Scala?</p><p>The only limitation is the args to pass must either be from the arg list of the current template or a new object created inline. You cannot declare a variable somewhere else and pass it to the super class, like in:</p><p><pre><br/>` String a = "hello"<br/>`extends myLayout(a)<br/></pre></p><h4 id="Definealocalmethodwithdef">Define a local method with <code>`def</code></h4><p>The <code>`def</code> command defines a local method that returns a String. The method can then be invoked in the same templates. <strong>def</strong> blocks are considered as local tags. It&#8217;s used to wrap a piece of rendering logic and presentation that can be reused in the the same template or its parent/children templates. <code>def</code> blocks can take parameters. You can invoke real tags from within the def body too. Using the local methods is just like calling a method. </p><p>An example:</p><p><strong>The child template</strong></p><p><pre><code><br/>`extends defLayout</p><p>`def foo<br/>    `String s = &#8220;hi there&#8221;;<br/>    hello $foo2(s)<br/>`</p><p>`def foo2(String p)<br/>    hi $p!<br/>    `tag SampleTag p<br/>`</p><p><strong>{ the old syntax of def }</strong></p><p>#{def bar}<br/>    `String s = &#8220;hi2&#8221;;<br/>    hi $s!<br/>#{/}</p><p>#{dummyTag get(&#8220;bar&#8221;)/}</p><p><strong>{ can call it directly }</strong></p><p>$foo()<br/></code></pre></p><p>The <code>`def foo</code> block defines a method named <code>foo</code>. The method body declares a variable <code>s</code> and then calls another local method named <code>foo2</code> with the variable. The <code>foo2</code> is defined to take a String argument. Both return a string which is the result of interpolating the data in the text of the bodies. The arguments received from the <code>`args</code> statement are available in the method bodies.</p><p>The methods defined in the templates can be invoked with reflection. Japid provides a predefined method named <code>get</code> (not to be confused with the <code>`get</code>) that can be used to invoke the method. In the above example, <code>#{dummyTag get("bar")/}</code> is the &#8220;old&#8221; classic Play! way of invoking a tag. The argument is actually a function call to invoke the <code>bar</code> method defined above it (in the classic Play! style again). One limitation though, the <code>get</code> method can only invoke method without parameters. Future Japid will probably have another <code>get</code> that can take additional arguments. </p><p>The <code>get()</code> can be used in either the super class or the child class to reflect methods. The following example uses it call the <code>foo()</code> defined in the child. </p><p><strong>defLayout.html</strong><br/><pre><br/>$get(&#8220;foo&#8221;)<br/>#{doLayout/}<br/></pre></p><p>Effectively the data is passed from the child to the layout. </p><h2 id="UsingImplicitDataObjectsinTemplates">Using Implicit Data Objects in Templates </h2><p>Although it has been said that all data passed to the templates must be declared, there are a few Play! specific objects, implicitly available in Japid templates. If you open any Java source code derived from the templates (including the views, layouts and tags), you&#8217;ll see in the main body that there are a few objects declared:</p><p><pre><br/>    final Request request = Request.current();<br/>    final Response response = Response.current();<br/>    final Session session = Session.current();<br/>    final RenderArgs renderArgs = RenderArgs.current();<br/>    final Params params = Params.current();<br/>    final Validation validation = Validation.current();<br/>    final cn.bran.play.FieldErrors errors = new cn.bran.play.FieldErrors(validation);<br/>    final play.Play _play = new play.Play();<br/></pre></p><p>First of all, please use the <a href="http://www.playframework.org/documentation/1.1.1/templates#implicits">Implicit objects available in a Play! template</a> as the background reference. </p><p>Japid implicit objects are comparable to those available in the standard Play! templates, but  is not strictly one-to-one matching. </p><ol><li><code>request</code>: same as in Play! standard</li><li><code>response</code>: not directly available in Play! standard, not advisable to use </li><li><code>session</code>: same as in Play! standard</li><li><code>renderArgs</code>: not directly available in Play! standard. Objects passed to this container can be retrieved in templates as <code>`MyType my = (MyType)renderArgs.get("aKey");</code>. </li><li><code>params</code>: same as in Play! standard, not advisable to use since all parameters are supposed to be passed in via the <code>`args</code> directive. </li><li><code>validation</code>: not directly available in Play! standard </li><li><code>errors</code>: comparable to the variable of the same name in Play! standard.</li><li><code>_play</code>: same as the <code>play</code> variable in Play! standard. The leading underscore is added to avoid possible name collision with user data. </li></ol><p>There are a few static objects made available by the JapidPlayAdapter import. </p><ol><li><code>flash</code>: a wrapper class <code>FlashWrapper</code> that wraps the Play! <code>Flash</code> class. </li><li><code>message</code>, same as in the standard Play! templates.  </li><li><code>lang</code>, same as in the standard Play! templates.  </li></ol><p>There is an <code>out</code> variable that is the content buffer for the current template. It&#8217;s an instance of StringBuilder and you can append content to it if you want. Use of <code>out</code> is not advisable. </p><p>Now I&#8217;ll describe some of the most useful implicit objects. </p><h3 id="TheflashObject">The <code>flash</code> Object</h3><p>The <em>flash</em> scope stores information that will be available in the current and the next HTTP request, including a <em>redirect</em>. </p><p>See <a href="http://www.playframework.org/documentation/1.1.1/controllers#session">Flash and Session</a> for the basic information. </p><p>The <code>flash</code> object is an instance of <code>cn.bran.play.FlashWrapper</code>, which wraps the Play! <code>Flash</code> class and provides a few handy methods, </p><ol><li><code>hasError()</code>: true if there is a message associated with the key &#8220;error&#8221;. This message can be created by invoking the <code>error(...)</code> method of the standard Flash object. </li><li><code>error()</code>: return the message associated with the &#8220;error&#8221; key.</li><li><code>hasSuccess()</code>: true if there is a message associated with the key &#8220;success&#8221;. This message can be created by invoking the <code>success(...)</code> method of the standard Flash object. </li><li><code>success()</code>: return the message associated with the &#8220;success&#8221; key.</li></ol><p>An example:</p><p>In the controller:</p><p><pre><code></p>   public static void flashbad() {
        flash.error(&#8220;something bad&#8221;);
        // redirect to 
        flashout();
    }   public static void flashMsg() {
        flash.put(&#8220;msg&#8221;, &#8220;a message&#8221;);
        // redirect to 
        flashout();
    }   public static void flashgood() {
        flash.success(&#8220;cool&#8221;);
        // redirect to 
        flashout();
    }   public static void flashout() {
        renderJapid();
    }<p></code></pre></p><p>In the view:</p><p><pre><br/>`// this is for demo the flash object, which is a wrapper of the Play&#8217;s flash object</p><p>`if flash.hasError() <br/>    $flash.error()<br/>`else if flash.hasSuccess()<br/>    ${flash.success()}<br/>`else<br/>    `if flash.contains(&#8220;msg&#8221;)<br/>        the message: $flash.get(&#8220;msg&#8221;)<br/>    `else<br/>        oh well<br/>    `<br/>`<br/></pre></p><p>Note we&#8217;re using the &#8220;open if-else&#8221; statement for fast typing. Of course you can do:</p><p><pre><br/>`if(flash.hasError()){ <br/>    $flash.error()<br/>`} else if (flash.hasSuccess()){<br/>    ${flash.success()}<br/>`} else {<br/>    `if (flash.contains(&#8220;msg&#8221;)) {<br/>        the message: $flash.get(&#8220;msg&#8221;)<br/>    ` } else {<br/>        oh well<br/>    `}<br/>`}<br/></pre></p><p>It&#8217;s plain Java stuff. </p><p>New: <code>flash.get("msg")</code> has been made simpler: <code>flash("msg")</code> </p><h3 id="Validationsanderrors">Validations and errors</h3><p>The Play! <a href="http://www.playframework.org/documentation/1.1.1/validation">validation</a>  is a good read. Get yourself familiar with that. </p><p>An object <code>validation</code> of the Play! <code>Validation</code> type is available in Japid templates. You can use the API to work with the validations and errors directly. </p><ul><li>Controller action:</li></ul><p><pre><br/>    public static void validate(String name, Integer age) {<br/>           validation.required(&#8220;name/姓名&#8221;, name);<br/>           validation.required(&#8220;age/年龄&#8221;, age);<br/>           validation.min(&#8220;age&#8221;, age, 10);<br/>           renderJapid(name, age);<br/>    }<br/></pre></p><ul><li>the view</li></ul><p><pre><code><br/>`args String name, Integer age</p><p>`if validation.hasErrors()</p>   <h1>Oops…</h1>   `for Error error: validation.errors()
        <p>$error.getKey() : $error</p>
    `
`else
    name is: $name, age is: $age
`
</code></pre><p>Compare this to the Play! version:</p><p><pre><code><br/>#{ifErrors}</p>  <h1>Oops…</h1>  #{errors}
       <li>${error}</li>
   #{/errors}<p>#{/ifErrors}<br/>#{else}<br/>   Hello ${name}, you are ${age}.<br/>#{/else}</p><p></code></pre></p><p>and you&#8217;ll notice that Japid is a little &#8220;raw&#8221;. </p><p>You can retrieve an <code>Error</code> object associated with a key using:</p><p><code>validation.error(key)</code></p><p>You can also use the errors object:</p><p><code>errors.forKey(key)</code></p><p>Which is simply a wrapper to the <code>validation</code> object. I feel like removing the <code>errors</code> implicit object in the future.  </p><p>New: </p><ol><li><code>validation.hasErrors()</code> has been made simpler: <code>hasErrors()</code>, just a static method invocation to the <code>Validation</code></li><li><code>validation.errors()</code> has been made simpler: <code>errors()</code>, just a static method invocation to the <code>Validation</code></li><li>To get the errors for a field/key: <code>List&lt;Error&gt; errors(String key)</code></li><li>To get the first error for a field/key: <code>Error error(String key)</code></li></ol><p>So the first example can be made simpler:</p><p><pre><code></p><p>`args String name, Integer age</p><p>`if hasErrors()<br/>    <h1>Oops…</h1></p>   `for(Error e: errors()){
        <p>$e.getKey() : $e </p>
    `}
`else
    name is: $name, age is: $age
`
</code></pre><h4 id="Customizingthevalidationmessages">Customizing the validation messages</h4><p>The default messages for each is in the <code>$PLAY_HOME/resources/messages</code> and I copied here:</p><p><pre><br/>validation.required=Required<br/>validation.minSize=Minimum size is %2$d<br/>validation.maxSize=Maximum size is %2$d<br/>validation.email=Invalid email address<br/>validation.range=Not in the range %2$d through %3$d<br/>validation.min=Cannot be lower than %2$d<br/>validation.max=Cannot be greater than %2$d<br/>validation.match=Must match %2$s<br/>validation.isTrue=Must be checked<br/>validation.equals=Must be equal to &amp;{%2$s}<br/>validation.invalid=Incorrect value<br/>validation.future=Must be in the future<br/>validation.after=Must be after %2$s<br/>validation.past=Must be in the past<br/>validation.before=Must be before %2$s<br/>validation.object=Validation failed<br/>validation.notFound=Object not found for id %2$s<br/>validation.url=Not a valid URL<br/>validation.phone=Not a valid phone<br/>validation.ipv4=Not a valid IP address<br/>validation.ipv6=Not a valid IP v6 address<br/></pre></p><p>You can override any of these in your <code>conf/messages</code> file. </p><p>For example, I can use Chinese as the error message:</p><p><pre><br/>    validation.required=不能为空<br/>    validation.min=不能小于 %2$d<br/></pre></p><h2 id="InvokingtemplatesinControllers">Invoking templates in Controllers </h2><p>Japid templates are compiled java classes which can be invoked statically or reflectively. </p><p>Note: to use Japid in a controller, one must let the controller to <code>extends</code> a special Japid controller super class named <code>cn.bran.play.JapidController</code>, instead of the Play!'s default <code>Controller</code> class. If you intend to use post-controller Japid integration. Please use the <code>cn.bran.play.JapidController2</code> as the super controller class instead. </p><h3 id="ExplicitTemplateBindingPreControllerIntegrationonly">Explicit Template Binding (Pre-Controller Integration only)</h3><p>Since all Japid templates are compiled to Java classes, one can use them directly anywhere, of course including in the controller actions. Given a template <code>japidviews/MyController/foo.html</code>, Japid will generate a Java class named <code>japidviews.MyController.foo</code>. The entry point of using this class is:</p><p><pre><br/>    public cn.bran.japid.template.RenderResult render(Bar bar)<br/></pre></p><p>The <code>RenderResult</code> object contains the text which is the result of the template rendering, and the additional HTTP headers. As you may have known, The Play! way to return a result from a controller method is to throw an object of <code>Result</code> type. To use the result from the template class, one needs to wrap it in a <code>cn.bran.play.JapidResult</code> object and throw it out, like this in a controller action:</p><p><pre><br/>    throw new JapidResult(new foo().render(args...));<br/></pre></p><p>Of course all the classes must have been properly imported before use or one must use the fully qualified names. </p><p>The <code>JapidContrller</code> super class offers a static method <code>render(RenderResult rr)</code> to hide the JapidResult, so one can write:</p><p><pre><br/>    render(new foo().render(myBar));<br/></pre></p><p>Slightly cleaner.</p><p>As you may guess, invoking a template class directly does not require the class to be in a specific package. There is no need to match the name or the package of the template with the name of the action, the class or the package. The minimum requirement is the templates are in the <code>japidviews</code> tree, since the template converter will only scan this tree for Japid templates. </p><h4 id="HowandwhenarethetemplatefilestranslatedtoJavasourcecode">How and when are the template files translated to Java source code?</h4><p>Three ways and timing.</p><h5 id="Conversionmethod1commandlinetoolsprecontrollerintegration">Conversion method 1: command-line tools (pre-controller integration)</h5><p>There are four Japid command-line commands that one can use in the application root:</p><ol><li><code>play japid:mkdir</code>: check the proper <code>japidviews</code> directory tree and create missing elements if necessary. </li><li><code>play japid:gen</code>: do <code>mkir</code> first then translate all templates in html, xml, json to Java sourse code. Most of the time this command supersedes the <code>japid:mkdir</code>.</li><li><code>play japid:clean</code>: remove all generated Java source files derived from the templates. </li><li><code>play japid:regen</code>: do <code>clean</code> and <code>gen</code></li></ol><p>These commands are useful in what I call the &#8220;cold development&#8221; mode &#8211; in compile-time and you use the <strong>static linking</strong> (a.k.a. <strong>explicit template binding</strong> ) of the templates, i.e., you instantiate the java class derived from the view template in the controller actions and invoke the render() method directly. </p><p>The workflow in this mode is:</p><ol><li>create the model classes if they&#8217;re to be rendered in the views.</li><li>create the Japid views in html. </li><li>run the <code>play japid:gen</code> to get the Java files derived from these templates. </li><li>statically link the renderer in the actions.  </li></ol><p>However as explained before, <strong>implicit template binding</strong> is a lot more flexible and does not require the use of the code generation tools. See the next section of this document.</p><p><strong>Tip!</strong> Let me show you how you can configure these commands in Eclipse to make using these commands less troublesome if you are using Eclipse as the main IDE to develop applications. </p><p>The most used command is probably <code>play japid:gen</code>. </p><p>Here are the steps to create a quick link to the command in Eclipse:</p><ol><li>Open menu: Run -&gt; External Tools -&gt; External Tools Configuration</li><li>Create a new entry with the following attributes:</li></ol><p><strong>Name</strong>: japid-gen</p><p>Under the <strong>Main</strong> tab:</p><ol><li><strong>location</strong>: D:\home\bran\projects\play\play.bat (change this to your start script of your Play! installation).</li><li><strong>Working Directory</strong>: ${project_loc}</li><li><strong>Arguments</strong>: japid:gen</li></ol><p>Under the <strong>Refresh</strong> tab:</p><ol><li>Check the "Refresh resources upon completion"</li><li>Select the "The project containing the selected resource"</li><li>Check the "Recursively include sub-folders"</li></ol><p>Now I can translate the latest templates to Java code right from the IDE with just two clicks. </p><p>Two other most useful commands are <code>play japid:regen</code> and <code>play eclipsify</code> (if you&#8217;re an Eclipse user). The latter is not directly related to Japid, but it&#8217;s convenient when you upgrade either the Play! installation or the Japid module.</p><h5 id="Conversionmethod2carefreeconversioninDEVmode.">Conversion method 2: care-free conversion in DEV mode.</h5><p>The Play! runtime in DEV mode detects file changes automatically before processing any new HTTP requests or <strong>job</strong> activation, and Japid module will step in to translate the newly added/changed template files automatically. Java files derived from removed templates will get removed automatically too. </p><p>Note: for the IDE to display any changes made to the derived Java files, it&#8217;s highly recommended to turn on <strong>auto-refresh</strong> on external file changes. Take Eclipse for an example:</p><ol><li>Open the <code>Window</code> menu in the main menu bar and open the <code>Preferences</code> menu item. </li><li>Open the <code>General -&gt; Workspace</code> panel and check the <code>Refresh    automatically</code> checkbox. </li></ol><p>Now the artifacts of Japid transforming process will be displayed instantaneously or with a short delay, depending on the size of the project and the OS you&#8217;re running. If you have an error in your template, the derived Java file will be marked with an error marker and you can take a look at it to find out what&#8217;s wrong with it.  </p><h5 id="Conversionmethod3usingtheJapidpluginforEclipseprecontrollerintegrationfornow">Conversion method 3: using the Japid plugin for Eclipse (pre-controller integration for now)</h5><p>There is a plugin for Eclipse that takes care of templates/Java synchronization at compile time. One don&#8217;t need to run the app in DEV mode to get the templates automatically translated. The detail is explained in a later section of this document.  </p><p>In conclusoin, there are good and bad sides of using a template explicitly as a Java class:</p><ul><li>Pros:<ol><li>fast, since this is a regular Java class instantiation and method invocation.</li><li>statically linked and thus there is compile-time check of argument binding. </li></ol></li><li>Cons:<ol><li>verbose: the classes need to be imported; the results need to be thrown out.</li><li>strict in workflow: one must write the templates first and convert them to Java classes (manually or automatically, depending on the development environment) before they can be used in controller actions. </li></ol></li></ul><h3 id="ImplicitTemplateBinding">Implicit Template Binding</h3><p>To decouple an action and the template it defaults to render, the <code>JapidController</code> or <code>JapidController2</code> provides a method <code>renderJapid(...)</code> to hide the process of invoking the renderer. The method depends on the parallel package structure of the <code>controllers</code> tree and the <code>japidviews</code> tree to locate the right template to render with. </p><p>For an example, given the action method <code>controllers.p1.MyController.foo(...)</code>, the default template name is <code lang="app/japidroot">/japidviews/p1/MyController/foo.html</code>.</p><p>The <code>renderJapid</code> makes binding to the default template a lot easier as shown below:</p><p><pre><br/>    public static void foo(...) {<br/>        Bar bar = ...;<br/>        renderJapid(bar);<br/>    }<br/></pre></p><p>Note: the Play!'s default rendering engine binds the arguments <strong>by name</strong>. This means one must give any objects to be passed to the template a name or the template engine won&#8217;t find them. In contrast Japid implicit argument binding binds arguments by position, just like in any java method invocations. One does&#8217;t need to match the names of the variables in the action with those in the templates. </p><ul><li>Pros:<ol><li>a lot shorter.</li><li>the templates do not need to exist and compiled to Java classes before template authors writing the action code. </li></ol></li><li>Cons:<ol><li>slightly slower, usually less than 1 <em>μs</em>, since it uses reflection to invoke the rendering code.</li><li>no compile-time check on the parameters. </li><li>need to match the directory structure of the japid templates to the controllers'. The <code>play japid:gen</code> or the Eclipse plugin would help to make it less a problem. </li></ol></li></ul><p>I personally find using the implicit template binding a lot easier on me, since I can work in the order of a request processing flow very naturally in this mode: the models, the controllers and then the views. I don&#8217;t need to manually convert the templates files at all. I need to however make sure the <code>japidviews</code> directory tree is synchronized with the <code>controllers</code> tree in terms of the package names and the files names. With the <strong>Japid Plugin for Eclipse</strong>, which is the IDE of my choice, I don&#8217;t even need to worry about the package structure and I can focus on the real coding logic. The Eclipse plugin will guide me to create the views in the proper locations, as described later in this document.</p><p>Now, what if there are multiple possible Japid templates to render with in an action?</p><p>Three ways:</p><p>1. statically link the template class as explained in the previous section.<br/>2. use the <code>JapidController.renderJapidWith() method</code>: <br/>for an example: </p><p><code>renderJapidWith("more/MyController/anotherTemplate.html", bar)</code> <br/>will render the <code>bar</code> object with the <code>japidviews/more/MyController/anotherTemplate.html</code> template. The template name is a relative name to the <code>japidviews</code> directory. </p><p>It can also be in the form of a Java class name: <code>more.MyController.anotherTemplate</code>. </p><p>You can specify the target target template in the same default directory using the &#8220;@&#8221; notation:</p><p><pre><br/>    renderJapidWith(&#8220;@anotherTemplate.html&#8221;, bar), or<br/>    renderJapidWith(&#8220;@anotherTemplate&#8221;, bar)<br/></pre></p><p>3. call other methods and render implicitly, i.e., <strong>action chaining</strong>. </p><p>The below example demonstrates all ways of template bindings:</p><p><pre><br/>    public static void foo() {<br/>        Bar b = ...;<br/>        if (cond1) {<br/>            // implicit binding<br/>            renderJapid(b);<br/>        }<br/>        else if (cond2) {<br/>            // action chaining<br/>            dontRedirect();<br/>            bar(b);<br/>        }<br/>        else if (cond3) {<br/>            // static linking<br/>            render(new foo().render(b));<br/>        }<br/>        else {<br/>            // explicit dynamic binding<br/>            renderJapidWith(&#8220;more.MyController.foo&#8221;, b);<br/>        }<br/>    }</p>   public static void bar(Bar b) {
        // implicit binding
        renderJapid(b);
    }     
</pre><p>In the above example, when <code>cond1 == true</code>, the template to render with is <code>foo.html</code>; when <code>cond2 == true</code>, <code>bar.html</code> will be used to render the data, etc. Note, <code>JapidController.dontRedirect()</code> must be called to avoid an HTTP <strong>redirect</strong>, since calling another action in Play! runtime will trigger an HTTP redirect. Please note, Play!'s original author does not like action chaining for some reason. In fact there is no way to do action chaining without creating an HTTP redirect with the classic Play! controllers. The <code>dontRedirect()</code> opens up the possibility.</p><h3 id="InvokingTemplateswithNamedArgument">Invoking Templates with Named Argument</h3><p>Since version 0.8.5, I have added support for invoking templates/tags with named arguments. </p><p><pre><br/>    renderJapidByName(named(&#8220;name&#8221;, &#8220;my name&#8221;), named(&#8220;age&#8221;, 100));<br/></pre></p><p>As of now, we&#8217;re not using the parameter name discovery mechanism provided by Play&#8217;s name enhancer. </p><p>The above calling convention offers a little advantage in that developers can omit some arguments provided they&#8217;re null. </p><h2 id="InvokingActionsinTemplates">Invoking Actions in Templates</h2><p>Sometimes I call this feature &#8220;dynamic server-side include&#8221;. </p><p>Let&#8217;s consider a porlet-like web page. It&#8217;s composed of multiple panels each of which displays totally different content. Let&#8217;s say we have already created controller actions and corresponding views to display each of the content panels. How can we reuse all the controllers and views as sort of &#8220;components&#8221; in the portlet page?</p><p>This is a page composition that is not supported by the default Play! rendering pipeline. </p><p>Japid provides a special command named <code>`invoke</code> or <code>`a</code> for action to help users to invoke a controller action right from a view template. </p><p>In a controller:</p><p><pre><code><br/>package controllers.more;<br/>import cn.bran.play.*;</p><p>public class Portlets extends JapidController /*or JapidController2*/ {<br/>    public static void index() {<br/>        renderJapid(&#8220;a&#8221;, &#8220;b&#8221;);<br/>    }</p>   public static void panel1(String a) {
        renderJapid(a);
    }   public static void panel2(String b) {
        renderJapid(b);
    }
}
</code></pre><p>Highlight anywhere in the index() method and <code>ctrl-alt-v</code> and say &#8220;yes&#8221; to the question and you are in the index.html. Change it to something like this:</p><p><pre><br/>`args String a, String b</p><p>`invoke controllers.more.Portlets.panel1(a)</p><p>`a controllers.more.Portlets.panel2(b)<br/></pre> </p><p>The <code>invoke</code>, or the short form <code>`a</code>, basically invokes the action method in the controller with the argument and incorporate whatever content the action generate right on the spot. Each of the controller action and view pairs becomes a reusable unit of component. This is a lot more powerful than other mechanisms such as <code>tags</code> since you have the full Java in your hand. </p><p>I feel this is very intuitive for many developers to compose complex pages, although the original Play! developers do not seem to like this idea. </p><h3 id="AdvancedCachingwithInvoke">Advanced Caching with Invoke</h3><p>The <code>`invoke</code> command can take one optional argument: a timeout value to cache the result from the action invocation. </p><p>Let&#8217;s change the above template a little bit:</p><p><pre><code><br/>    `args String a, String b</p>   `invoke controllers.more.Portlets.panel1(a)   `a controllers.more.Portlets.panel2(b), "10s"
</code></pre><p>I have attached a timeout specification to the second action invocation. The timeout value is a string such as &#8220;1s&#8221;, &#8220;2mn&#8221; (&#8220;mn&#8221; for minute), &#8220;3h&#8221; and &#8220;4d&#8221; (&#8220;29d&#8221; maximum), to specify how long to cache the result content from the action.  </p><p>There is another way to specify if the result should be cached and for how long: using the Play! <code>CacheFor</code> annotation on the action, like this:</p><p><pre><br/>package controllers.more;<br/>import play.cache.CacheFor;<br/>import cn.bran.play.JapidController;</p><p>public class Portlets extends JapidController {</p>   @CacheFor(&#8220;10s&#8221;)
    public static void panel2(String b) {
        renderJapid(b);
    }
}
</pre><p>Note: The timeout spec in the <code>`invoke</code> command overrides any <code>CacheFor</code> annotation. </p><p>Now on to the &#8220;advanced&#8221; part, <strong>nested caching</strong>. </p><p>What if the first level cached content is from a template that contains another cached <code>`invoke</code>? Will the outer cache &#8220;annihilate&#8221; the inner cache? The answer is &#8220;no&#8221;.</p><p>This is what will happen: the inner cache will <em>penetrate</em> the outer cache and operate by its own timeout pace. Consider a scenario where a complex home page (in our example the index.html) is cached for 20 seconds, but the headline news section (the panel2.html in our example) on the page will need to be updated very 10 seconds (or refresh every time a new request comes in). </p><p>An Example: </p><p><strong>The controller:</strong></p><p><pre><code><br/>package controllers.more;<br/>import java.util.Date;</p><p>import play.cache.CacheFor;<br/>import cn.bran.play.*;</p><p>public class Portlets extends JapidController /*or JapidController2*/ {<br/>    @CacheFor(&#8220;20s&#8221;)<br/>    public static void index() {<br/>        renderJapid(&#8220;a&#8221;, &#8220;b&#8221;);<br/>    }</p>   public static void panel1(String a) {
        System.out.println(&#8220;panel1 called&#8221;);
        renderJapid(a);
    }   public static void panel2(String b) {
        System.out.println(&#8220;panel2 called&#8221;);
        renderJapid(b);
    }   @CacheFor(&#8220;5s&#8221;)
    public static void panel3(String whatever) {
        System.out.println(&#8220;panel3 called&#8221;);
        renderText("<div>" + new Date() + "</div>");
    }
}
</code></pre><p>The view:</p><p><pre><code><br/>    `args String a, String b</p><p>The outer most content is cached for 20 seconds, using the CacheFor annotation. ${new Date()}</p><p>this part is never cached.<br/>    `invoke controllers.more.Portlets.panel1(a)</p><p>this part is cached for 10 seconds. Note the timeout spec with invoke overrides CacheFor annotation.<br/>    `a controllers.more.Portlets.panel2(b), "10s"</p><p>this part is cached for 4 seconds, specified with CacheFor annotation in the controller.<br/>    `a controllers.more.Portlets.panel3(a + b)<br/></code></pre></p><p>With this composition pattern, the whole page will be cached for 20 seconds, and the <code>panel2</code> will be cached for 10 seconds, the <code>panel3</code> is cached for 4 seconds since the action is annotated with a <code>CacheFor("4s")</code>. The panel1 part will not be cached at all since there is no cache control at all. </p><p>If you have sharp eyes, you may notice that the content in a cached block is usually updated one second before the specified timeout value. Japid builds a mechanism to <strong>pre-expire</strong> an entry 1 second in advance. The first client to get the <strong>pre-expire</strong> is responsible for updating the cache while other requests coming during the one second window will still get the cached entry until the entry is <strong>fully expired</strong>. This mechanism is to make sure the cache will be updated by only one thread thus perform seamlessly in a highly concurrent environment.  </p><h5 id="howtopenetratethecacheprogrammatically">how to penetrate the cache programmatically?</h5><p>Since version 0.9.4.4, programmer have a couple of APIs in the <strong>JapidController</strong> to control the use of a cached JapidResult that is resulted from the use invoke in the Japid templates. </p><p>1. <strong>public static void ignoreCache()</strong>: use this method to tell Japid not to use any cached JapidResult in the current request processing cycle. <br/>2. <strong>public static void ignoreCacheNowAndNext()</strong>: use this method to tell Japid not to use any cached JapidResult in the current request processing cycle and the next cycle. The idea is to ensure a redirect after change will see the latest state in the database rather than the stale rendered results from previous rendering. <br/>3. <strong>public static &lt;C extends JapidController&gt; void evictJapidResultCache(Class<C> controllerClass, String actionName, Object... args)</strong>: use this method to evict a cached Japid result resulted from a Japid directive <strong>invoke</strong>. It can be used in a controller action to invalidate a cached result from calling the controller action with the specified arguments. </p><p>Currently all cached Japid <strong>invoke</strong> results are stored with keys synthesized with the controller name, action name and the arguments. The id attribute of the <strong>CacheFor</strong> annotation is not yet supported. </p><h2 id="UseJapidtoRenderEmailContent">Use Japid to Render Email Content</h2><p>Japid has a replacement for Play!'s email rendering engine. The mechanism is very similar to the <a href="http://www.playframework.org/documentation/1.1.1/emails">Play!'s email rendering flow</a>, but takes full advantage of Japid templates. </p><p>This is how:<br/>1. Create a <code>mail controller</code> (a.k.a. <code>mailer</code>) in <code>app/notifiers</code> or any sub-directory of it. A <code>mailer</code> is conceptually equivalent to an action controllers except it must extend <code>cn.bran.play.JapidMailer</code> or <code>cn.bran.play.JapidMailer2</code> if you&#8217;re using JapidController2. Here is a sample mailer:</p><p><pre><br/>public class CouponJapidMailer extends JapidMailer /* or JapidMailer2 */ {<br/>    public static void sendEditorEmail(String title, String content) {<br/>        setSubject(title);<br/>        addRecipient(&#8220;bing_ran@hotmail.com&#8221;);<br/>        setFrom(&#8220;memberships &lt;memberships@maimaijia.cn&gt;&#8221;);<br/>        // add an attachment<br/>        EmailAttachment attachment = new EmailAttachment();<br/>        attachment.setDescription(&#8220;A pdf document&#8221;);<br/>        attachment.setPath(Play.getFile(&#8220;rules.pdf&#8221;).getPath());<br/>        addAttachment(attachment);<br/>        send(content);<br/>    }<br/>}<br/></pre></p><ul><li>The <code>send</code> method is the counterpart  of <code>renderJapid(...)</code> in regular controller. It searches for the <code>japidviews/_notifiers</code> directory for the matching template. e.g.:</li></ul><p>Given a mailer action <code>sendNote()</code> in:</p><p><pre><br/>app/notifiers/MyNoti.java<br/></pre></p><p>The <code>send()</code> action&#8217;s default template is:</p><p><pre><br/>{japid root}/japidviews/_notifiers/MyNoti/sendNote.html<br/></pre></p><p>If the mailer is </p><p><pre><br/>app/notifiers/org/MyNoti.java<br/></pre></p><p>then the default template is:</p><p><pre><br/>{japid root}/japidviews/_notifiers/org/MyNoti/sendNote.html<br/></pre></p><p>2. Create the email content renderer as you would do for any regular Japid view templates. You can use the full capacity of Japid of course, including layouts, tags, etc.</p><p>3. Invoking a mailer in your controller actions as you would invoke a static method. e.g.:</p><p><pre><br/>    // in a regular controller<br/>    public static void feedback(String title, String content) {<br/>        // ...<br/>        CouponJapidMailer.sendEditorEmail(title, content);<br/>    }<br/></pre></p><p>Note:</p><ol><li>The email sending process takes place in the current thread therefore it is a synchronous process. This has impact on the scalability of sending large amount of emails simultaneously. This is an area for future improvement.</li><li>The mailer can be invoked in Play! jobs in the same way.</li></ol><h2 id="UsingtheJapidEclipsePluginPreControllerIntegrationOnly">Using the Japid Eclipse Plugin (Pre-Controller Integration Only)</h2><p>First of all, the plugin is based on the PlayClipse project for Play! In fact the new plugin still keeps the name and tries to keep itself compatible with the default rendering engine. </p><h3 id="Sourcecode">Source code</h3><p>- https://github.com/branaway/playclipse, branched from https://github.com/erwan/playclipse</p><h3 id="Features">Features:</h3><ol><li>It provides a few &#8220;wizards&#8221; to help create Japid Play! classes/files.</li><li>It integrates the Japid template transforming process to the incremental and full project building processes of Eclipse, thus eliminates any manual process in applying Japid templates.</li><li>The plugin as of now offers the same level of features that are in the original plugin for the  groovy-based templates to the Japid template engine.</li><li>It enables some menu items and short-cuts to navigate between actions and Japid views, japid html templates and the derived Java source code. </li><li>It provides an enhanced Play HTML editor that recognizes some Japid syntax, notably the back single quotation mark syntax &#8211; the flagship Japid syntax.  </li><li>It enables Ctrl-click navigation in html views to actions, layout templates and tags. </li><li>It has also fixed a few bugs coming with the original plugin and enhanced the pop-up menu in the views and editors.</li></ol><h3 id="Installation">Installation:</h3><p>The plugin is in the <code>eclipse-plugin</code> directory of the Japid module. </p><ol><li>Put the jar file in the <code>dropins</code> directory of the Eclipse installation and start/restart the IDE. </li><li>You&#8217;ll be able to see a new menu named &#8220;JapidPlay&#8221; in the main menu bar. A new entry of the same name is also added to the context menu in the Java package navigation view, Java editor. A new html editor called <acronym title="Play">HTML</acronym> is also registered as an editor for html files. You&#8217;ll need to use this editor to edit HTML templates to gain the syntax highlighting, artifact navigation etc. </li></ol><p>If you don&#8217;t see the JapidPlay menu in the IDE workbench window menu bar, please try starting the IDE with a command line option : </p><p><pre><br/>$ ./eclipse -clean <br/></pre></p><p>The plugin has been tested with Eclipse Helios (3.6).</p><p>Got troubles?</p><ol><li>If you have used the classic PlayClipse plugin, please remove it from the <code>dropins</code> directory of your Eclipse installation and use the <code>-clean</code> command line option to start the IDE.  </li><li>Another trick is to remove the plugin jar before starting Eclipse. Once you&#8217;re in, shut it down. Put the jar in the <code>dropins</code> and start the IDE again. </li></ol><h3 id="Usage">Usage</h3><p>First of all, right click on your Japid/Play project and invoke menu <code>JapidPlay! -&gt; "Enable Play! Nature"</code> or the Japid transformation will not be integrated with the project building process, neither the popup menu will display the proper menu items.</p><p>The enablement of the Play nature does a few things:</p><ol><li>It adds a Japid builder in the project builders list, before the Java builder. </li><li>The builder creates the necessary <code>japidviews</code> tree if it&#8217;s not there. This is the equivalent to the <code>play japid:mkdir</code> command. </li><li>The builder also adds two files in the <code>japidviews</code> tree: <code>SampleLayout.html</code> in the <code>_layouts</code> and <code>SampleTag.html</code> in the <code>_tags</code> directory. These two files are not required by Japid <em>per se</em>. They are simply examples. Please leave them there since (actually the plugin will create them if you delete them.) any example views created by the Japid plugin reference them and there will be compile-time errors without them. I figure this is good for Japid beginners, but it may change in the future.</li><li>The builder does a fresh template translation and convert html templates to java source code, which is automatically picked up by the Java builder.</li></ol><p>Now click on the <code>controllers</code> directory or sub-directory to select it and invoke &#8220;New Controller&#8221; command from the main &#8220;JapidPlay&#8221; menu or the context menu (by right-clicking on the package node). Of course you can create the class without bothering the wizards. </p><p>Assuming you have highlighted the <code>controllers.more</code> node, the default controller created by the plugin looks like this:</p><p><pre><br/>package controllers.more;<br/>import play.mvc.*;</p><p>import cn.bran.play.JapidController;</p><p>// make sure you have <br/>//      module.japid=${play.path}/modules/japid-{version}<br/>// in your application.conf file, and "play eclipsify"<br/>// if you notice the JapidController is not found.</p><p>public class MyController extends JapidController {</p>   public static void index() {
        renderJapid(&#8220;Hello world!&#8221;, 123);
    }<p>}<br/></pre></p><p>As you can tell, the sample controller renders data with the default Japid template. Now let&#8217;s try navigating from the action to the default view. </p><p>Move the cursor to anywhere in the action method, which starts from the <code>public</code> modifier and ends at the closing curly brace of the method. Now you can navigate to the view either opening the main JapidPlay menu and invoke the &#8220;Go to view&#8221; item or right-clicking to bring up the context menu and invoke <code>JapidPlay! -&gt; Go to view</code>. Of course <code>Ctrl-Alt-v</code> is very handy here.</p><p>Since you don&#8217;t have the view ready yet, the plugin asks if you would like to create a view at the proper location. Saying &#8220;yes&#8221; and you&#8217;ll get a sample view created in the right location.</p><p><pre><br/>`extends SampleLayout.html<br/>`args String s, int i </p><p>`set title:"index"</p><p>hello ${s}, ${i}.<br/>Here goes your Japid template content.</p><p>call a tag: </p><p>`tag SampleTag &#8220;world&#8221; <br/></pre></p><p>It should have already been compiled to a Java file named &#8220;index.java&#8221;, and the Java code should compile clean, assuming that you have enabled the &#8220;Play Nature&#8221; on the project. If you don&#8217;t see the derived Java file in the same package, follow this procedure:</p><p><pre><br/>    if (you have enabled the &#8220;Play nature&#8221;) {<br/>        invoke &#8220;JapidPlay! -&gt; Disable Play! nature&#8221; on the context menu;<br/>    }<br/>    invoke &#8220;JapidPlay! -&gt; Enable Play! nature&#8221; on the context menu;<br/></pre></p><p>I have found occasionally I need to re-enable the Play! nature to get the Japid auto-compilation going. This is an issue to be explored. </p><p>The Japid plugin automatically synchronizes the html templates to the derived Java files if the project is set to build automatically: </p><ol><li>when you add a new template, a new Java file is derived from it and is placed in the same package. You can immediately spot any errors in the generated Java code and change your template to fix it. Here you get the full benefit of static typing.</li><li>when you update a template, the derived Java file is also updated. Again, you get the error checking. </li><li>when you delete or rename a template, the derived Java file is also removed or renamed accordingly. </li><li>when you invoke the <code>Project -&gt; clean</code> menu command, all the derived Java files are removed. If the &#8220;Build automatically&#8221; option is on, all the templates are translated to Java files immediately, effectively equivalent to the <code>play japid:regen</code> command. </li></ol><p>The template editor also does some basic error checking and rudimentary code completion, but it is far from being a sophisticated full-featured template editor. It does not</p><ol><li>edit html tags.</li><li>do serious code completion.</li><li>parse in the Java expressions.</li></ol><p>But I have found it offers great assistance in navigating the code, which makes the users a lot more productive.</p><h3 id="Navigatingintheviews">Navigating in the views</h3><p>The plugin offers an HTML editor that is Japid-aware. </p><p>If you have already used another HTML editor in your Eclipse IDE, usually your html files are associated with them and are opened in one of them. You&#8217;ll need to use the HTML editor from the plugin to take advantage of some of the nice features. </p><p>In the <code>Package Explorer</code>, right-click on the template file and <code>Open with -&gt; HTML(Play!)</code>. </p><p>The current Play html editor is unfortunately not HTML-aware(something to improve on later), but it offers some nice Japid-aware features:</p><ol><li>highlighting Japid constructs: Japid expressions, scripts, commands such as <code>`tag</code>, <code>`extends</code>, etc. </li><li>Ctrl-clicking on the <code>layouts</code>, <code>tags</code>, <code>imports</code> directives to navigate to the target files. </li><li>navigating to the controller action that uses this template as the default templates with the <code>Go to action</code> context command, or simply <code>ctrl-alt-a</code>. I find myself using this key combination and <code>ctrl-alt-v</code> a lot to switch between  the actions and the views.  </li><li>navigating to controller actions in the reverse route lookup expression: <code>controller.action(), again, with the @Go to action</code> command.</li><li>navigating to the derived Java files, with the <code>Go to generated Java file</code> context command.   </li></ol><h2 id="DebuggingtheTemplates">Debugging the Templates</h2><p>Since all Japid templates are transformed to Java source files, debugging the views is as easy as debugging any Java code in Play!. Nothing fancy here. </p><p>I personally find it rare to need to debug the views, since usually it will work if the Java code compiles. That&#8217;s compile-time error checking at work. You&#8217;ll need to pay attention to the parameter list of the templates and make sure they match that in the actions that using <strong>implicit template binding</strong>.   </p><p>If you need to output more monitoring information to the console or to the generated content, please read on.</p><h3 id="Loggingvariablestotheconsole">Logging variables to the console</h3><p>There is a handy command you can use to quickly log any data in your Japid templates. The command is naturally called <code>`log</code>. </p><p><pre><br/>`args String a</p><p>`log<br/>`log &#8220;the value of a: &#8221; + a<br/>`log 1 + 2</p><p></pre></p><p>The <code>log</code> command will print the string value of whatever Java expression following it to the system console, with template name and line number information, such as </p><p><pre><br/>japidviews/templates/log.html(line 5): <br/>japidviews/templates/log.html(line 6): the value of a: Hello <br/>japidviews/templates/log.html(line 7): 3<br/></pre></p><p>By the way, you can use the <code>log</code> command without any arguments. You end up with just the template name and line number in the console, useful if you want to know where you are. </p><h3 id="Traceingtemplatenestingsintheoutput">Traceing template nestings in the output</h3><p>A page of any complexity may have comlicated nestings: the layout, lots of tag use, and tag use in tags, nested action invocation, etc. As the template size grows, it gets harder and harder to easily follow what part of and html/json source code has been generated from what japid view file. </p><p>Since Japid 0.9.3.3, there are a few more application.conf settings and a new template directive to help you trace the template nestings. </p><h4 id="japid.trace.fileonoff">japid.trace.file = on/off</h4><p>Used in the &#8220;application.conf&#8221; file, when the value is &#8220;on&#8221;, a line of comment text is printed to the rendered content:<br/>    for html/xml content types:  <pre>&lt;!&#8212; enter: &#8220;japidviews/...&#8221; --&gt;</pre> at the point of rendering a view and <pre>&lt;!&#8212; exit: &#8220;japidviews/...&#8221; --&gt;</pre> after the view has been rendered.<br/>    for javascript/json content types: <pre>/*enter &#8220;japidviews/...&#8221;*/</pre> at the beginning of the template and <pre>exit: "japidviews/..."</pre> at the end. </p><h4 id="japid.trace.file.htmlonoff">japid.trace.file.html = on/off</h4><p>The switch controls the tracing of html/xml rendering templates specifically. It overrides the <code>japid.trace.file</code> setting. </p><h4 id="japid.trace.file.jsononoff">japid.trace.file.json = on/off</h4><p>This switch controls the tracing of the templates that generate jons/javascript mime types. Note, you can use <code>`json</code> or <code>`javascript</code> directive to force the content type of any templates. </p><h4 id="tracefile"><code>`tracefile</code></h4><p>This a directive for use in template and control the per-file tracing. When <code>`tracefile on|yes|true</code> is present in a template file, the tracing of this file is enabled, otherwise the tracing is turned off. </p><p>This directive overrides any settings in the application.conf file. </p><h2 id="UsetheSampleApplicationintheModule">Use the Sample Application in the Module</h2><p>There is a sample application distributed with the japid module in the <code>JapidSample</code> directory. It does not serve any real world purpose other than as a demo of Japid features.  </p><p>The same app has been ported to using Post-Controller model, as in the <code>JapidSampleDecoupled</code> folder. </p><p>This is how to run the sample:</p><ol><li>open the <code>application.conf</code> to make sure it has a proper reference to the japid module.</li><li>run command <code>play japid:regen</code> to regenerate all the template Java code.</li><li>if you would like to load it in Eclipse for example, you run <code>play eclipsify</code> command and open it in Eclipse. </li><li>start the application and hit <code>http://localhost:9000/</code>, you&#8217;ll get a page with many links to different actions.</li><li>follow those links to see how each features are used in the demo code. </li></ol><h2 id="UseJapidinModulesversion0.8.7orlater">Use Japid in Modules (version 0.8.7 or later)</h2><p>Play modules are used for </p><ol><li>providing development and runtime tools.</li><li>Composing multi-aspects big applications, with each part of separated functionality as a module. </li></ol><p>Let see how we can use Japid in Module for application composition.</p><p>The way Japid is used in modules is almost the same as it being used in a standalone application. However, The Japid template files need to be compiled to Java files separately from the &#8220;main&#8221; application. The Japid tool won&#8217;t detect any changes in the template file in the modules. Therefore if one makes changes to the Japid files in a module, he/she must compile the file from within the module. </p><p>Here are the steps:</p><p>1 The &#8220;play japid:xxx&#8221; requires the currrent directory is a valid application. Therefore we need to put a dummy <code>application.conf</code> in the module&#8217;s conf directory. <br/>2 Create a reference to the Japid module either in the application.conf or follow the new dependency management model and add an entry in the <code>dependencies.yml</code> file, like</p><p><pre><br/>self: play -&gt; mymodule 0.1</p><p>require:<br/>    - play<br/>    - play -&gt; japid 0.8.10<br/></pre></p><p>Then run</p><p><pre><br/>play deps<br/></pre></p><p>Or:</p><p><pre><br/>play deps --sync<br/></pre></p><p>3. Create controller and Japid templates files as in usual Japid applications. You can use the <code>play japid:xxx</code> commands to manipulate the Japid assets as you wish. </p><p>4. Update the <code>routes</code> file in the module to set up the URL access patterns, again as usual.</p><p>Back in the main application, set up your main app&#8217;s dependency on your module as usual and update your &#8220;routes&#8221; file to create an access path to your modules, like</p><p><pre></p><ul><li>      /mymodule                                 module:mymodule</li></ul><p></pre></p><p>Now you should be able access your module normally. </p><p>Everytime you change the code in the code in the module, you&#8217;ll need to compile them separately.</p><p>Perhaps I can make this smarter in the future.</p><h2 id="i18n">i18n</h2><p>Reference: <a href="http://www.playframework.org/documentation/1.1.1/i18n">Play! i18n</a></p><p>Everything said in the above documentation is supported in Japid. </p><p>There is one more API to retrieve an externalized messages, as illustrated in the following code snippet:</p><p>A Sample view:</p><p><pre><code><br/>login: &amp;{&#8216;login.name&#8217;} <br/>    or: ${i18n(&#8220;login.name&#8221;)}<br/></p><br/>customer name: &amp;{&#8216;cus.name&#8217;, &#8220;冉兵&#8221;} <br/>            or: ${i18n(&#8220;cus.name&#8221;, &#8220;Bing Ran&#8221;)}<br/></code></pre></p><p>The method <code>i18n()</code> basically calls the <code>Messages.get(...)</code>.</p><h2 id="ReverseURLLookup">Reverse URL Lookup</h2><p>Play! uses the mapping rules in the <code>conf/routes</code> to map URLs to controller actions. This is very powerful. What is more powerful is to do the &#8220;reverse&#8221; mapping: to map a expression of a action invoke back to a valid URL. </p><p>For example: if the rule maps <code>/myaction/{id}</code> to <code>more.MyController.action(id)</code>, the reverse lookup is to map the latter to the former. The core syntax is </p><p><pre><code><br/>    @{package.Controller.action(arg1, arg2...)}<br/></code></pre></p><p>for generating a relative URL from the host; and</p><p><pre><code><br/>    @@{package.Controller.action(arg1, arg2...)}<br/></code></pre></p><p>for generating an absolute URL including the host part.</p><p>The most common use case for the reverse lookup is to set the <code>href</code> attribute for the <code>a</code> tags and the <code>action</code> attribute for the <code>form</code> tags.</p><p>A sample view:</p><p><pre><code><br/>`String name = &#8220;bran&#8221;;<br/><a href="@{validate(name)}">simple reverse lookup</a><br/><a href="@@{validate(name, 12)}">simple reverse lookup with absolute url</a><br/><form action="@{validate()}"><br/>    <input type="hidden" name="name" value="bran"/><br/>    <input type="hidden" name="age" value="12"/><br/>    <input type="submit"/><br/></form><br/><a href="@{more.MyController.echo(name)}">simple reverse lookup</a><br/></code></pre></p><p>Note:</p><ol><li>When there is no controller identifier in front of the action name, it&#8217;s assumed the controller is the current contoller that invoking this the template. </li><li>The reverse lookup takes place at rendering time, and it&#8217;s expensive.</li></ol><p>There are a few methods available in you Java code, again imported from <code>JapidPlayAdapter</code>:</p><ul><li><code>String lookup(String action, Object... args)</code>: the <code>action</code> parameter is the controller plus action name, the args must be in the order of the parameters in the action.  </li><li><code>String lookupAbs(String action, Object... args)</code>: same as above except it returns the full URL including the host.</li><li><code>String lookupStatic(String resource)</code>: look up the URL for the static resource, such as JavaScript, CSS, etc. </li><li><code>String lookupStatic(String resource)</code>: same as above except it returns the full URL including the host.</li></ul><h2 id="ContentNegotiation">Content Negotiation</h2><p>Reference: <a href="http://www.playframework.org/documentation/1.1/routes#content-negotiation">Content Negotiation in Play!</a>. </p><p>Japid tries to match the template to render to the <code>Accept</code> HTTP header of a user agent. This happens when we use <code>renderJapid()</code>, i.e., implicit template binding.</p><p>For the same controller action there can be multiple target templates to render depending on the client expections:</p><ul><li>if the client accept <code>html</code>, the target defaults to <code style="action name">.html</code> </li><li>if the client accept <code>xml</code>, the target defaults to <code style="action name">.xml</code></li><li>if the client accept <code>json</code>, the target defaults to <code style="action name">.json</code></li><li>if the client accept <code>JavaScript</code>, the target defaults to <code style="action name">.js</code></li><li>if the client accept <code>CSS</code>, the target defaults to <code style="action name">.css</code></li></ul><p>Please note that the template translator maps the templates with an extension other than HTML to Java source file with the following naming pattern:</p><p><pre><br/>{action name}.{extension}  -&gt; {action name}_{extension}.java <br/></pre></p><p>The &#8220;Content-Type&#8221; header of the HTTP response is properly set in the above cases. </p><p>Japid allows you to set the <code>Content-Type</code> explicitly. </p><ul><li>Use a directive named <code>`contentType</code></li></ul><p><pre><br/>`// some examples<br/>`contentType text/html; charset=utf-8<br/>`contentType text/xml; charset=utf-8<br/>`contentType application/json; charset=utf-8<br/>`contentType application/x-javascript; charset=utf-8</p><p></pre></p><p>To make it a lot simpler you can simply use a set of directive that does not require you to remember the exact correct format:</p><p><pre><br/>`txt<br/>    `// for (&#8220;text/plain; charset=utf-8&#8221;),<br/>`xml<br/>    `// for (&#8220;text/xml; charset=utf-8&#8221;),<br/>`json<br/>    `// for (&#8220;application/json; charset=utf-8&#8221;),<br/>`css<br/>    `// for (&#8220;text/css; charset=utf-8&#8221;),<br/>`js<br/>    `// for (&#8220;application/x-javascript; charset=utf-8&#8221;),<br/></pre></p><p>BTW, you can directly manipulate the content type using the implicit object <code>response</code>:</p><p><pre><br/>`response.contentType = "text/xml; charset=utf-8"<br/></pre></p><p>Not recommended though. </p><h2 id="UsingGroovyandJapidintheSameProject">Using Groovy and Japid in the Same Project</h2><p>Japid is a module to bring another rendering engine for developing Play! applications. It does not replace the default Groovy-based template engine. It&#8217;s not one-or-the-other situation. In fact they can co-exist in the same project. </p><p>Controllers extending <code>Controller</code> will work as usual, meaning they search the <code>app/views</code> directory for the matching Goorvy-based templates, while those extending <code>JapidController</code> will use Japid, meaning use the <code>app/japidview</code> tree to store Japid templates. </p><p>The emailer is likewise. Both the Groovy-emailer and Japid emailer can exist in the same projects. </p><p>You can even render with Groovy in Japid controllers by simply calling <code>render(...)</code> methods instead of <code>renderJapid(...)</code></p><h2 id="Futurework">Future work</h2><ol><li>keep improving the Eclipse plugin</li><li>find more ways to simplify japid syntax.</li><li>keep improving the documentation.</li><li>assimilate some fancy features from the <code>Lift</code> framework. Parallel action blocks comes to my mind. </li><li>release a package that can be used in any Java projects.</li></ol><p>Thanks for your interests in Japid!</p><h2 id="PlayDefaultSyntaxv.s.Japid">Play! Default Syntax v.s. Japid</h2><p>Functionally, Japid provides a few features that are missing from the standard Play! trmplates. For exmaples:</p><ol><li>Invoking actions from the templates, with the <code>`invoke/`a</code> command, with advanced cache control. This is the Japid&#8217;s way of component-based page compositon. </li><li>Defining local methods in templates with the <code>`def</code> command, a light-weighted way of reusing rendering logic and presentation in the same template. </li><li>The <strong>import</strong>. Play! default must use the full qualified name to access static methods because you cannot do &#8220;import&#8221;. In Japid you can simply do &#8220;import static&#8221; to import all the great static methods you have designed and use them as if they&#8217;re part of your tempates. </li></ol><p>Now let&#8217;s look at some of the Play! syntax and how similar things are done in Japid.</p><p>Japid has adopted most of the notations in the classic Play! templates.  </p><ul><li><code>*{ }*</code>: the server side comment block. Sometimes I use <code>`//</code> to make a one line comment. </li><li><code>%{ }%</code>: the code block. Most of the time I like the ` lead code line though.  </li><li><code>${ }</code>: the Java expression. Japid allows one to drop the curlies if won&#8217;t cause any confusion. </li><li><code>&amp;{ }</code>: the message block.</li><li><code>#{ }</code>: the tag block. Note that named parameters are not supported. Many of the buidt-in tags has corresponding <code>command</code> form that use the back quote, such as <code>extends</code>, <code>set</code>, <code>get</code>, etc. </li></ul><p>The following list starts with the tags available in standard Play! and gives the Japid counterpart. An explaination is given if a couterpart is missing. </p><ul><li><code>flash['user.name']</code>: </li></ul>   <code>flash.get("user.name")</code> or simply: <code>flash("user.name")</code>. There is an implicit object named <code>flash</code> and a method <code>flash()</code>, implicitly imported from the <code>cn.bran.play.JapidPlayAdapter</code> class. Don&#8217;t be confused:)<ul><li><code>#{ifErrors}</code>: </li></ul>   use the <code>hasErrors()</code> with <code>`if</code>: <code>`if hasErrors()</code>. Again the method is from the <code>JapidPlayAdapter</code>. <ul><li><code>#{else}</code>: </li></ul>   <code>`else</code><ul><li><code>#{ifnot xxx}</code>: </li></ul>   <code>`if ! xxx</code>, <code>`else if ! xxx</code>.<ul><li><code>#{errors}</code>: </li></ul>   use the <code>errors()</code> method in a for loop:<p><pre><code><br/>    `for Error e: errors()<br/>       <p>$e</p><br/>    `<br/></code></pre></p>   I might consider adding a special command for that.<ul><li><code>#{authenticityToken/}</code>: </li></ul>   use the <code>authenticityToken()</code> method, in an expression.<p><pre><code><br/>    <form action="xxx"><br/>        $authenticityToken()<br/>        &lt;input .../&gt;<br/>    </form><br/></code></pre></p><ul><li><code>#{form ...}</code>: </li></ul>   this tag does not do much more than embedding the <code>$authenticityToken()</code>. So use the http <strong>form</strong> tag instead and add the authenticity token manually.<ul><li><code>#{field ...}</code>: </li></ul>   I can live with <strong>input</strong> tags.<ul><li><code>#{jsAction ...}</code>: </li></ul>   Japid provides a static method  for that, <code>jsAction(action, arg1, arg2)</code>: 
    for:
<pre>
        #{jsAction \@form(&#8216;:name&#8217;, &#8216;:age&#8217;)}, 
</pre>    
    we have a Japid version:
<pre>
        $jsAction(&#8220;form&#8221;, &#8220;:name&#8221;, &#8220;:age&#8221;)
</pre>   You know that <code>:name</code> etc are to generate a URL with named place holders, don&#8217;t you?<h2 id="PerformanceTips">Performance Tips</h2><p>If you&#8217;re so paranoid about your template performance, here are some of the tips to author Japid templates. </p><ul><li>All the general web site performance tips apply. </li><li>Use <code>cacheFor()</code> annotation.</li><li>All the field access in the model classes are transformed to invoke the <code>FieldAccessor.invokeReadProperty()</code> &amp; <code>FieldAccessor.invokeWriteProperty()</code> and those two methods use reflection to finish the work. My advice is always create the getter and setter yourself if you&#8217;re performance conscious. </li><li>The @{} reverse URL lookup is expensive. Use it cautiously. </li><li>Invoking tags are more expensive than using local methods defined by <code>def</code></li><li>Use raw Java constructs, such as the <code>if</code> and <code>for</code>, particularly the the &#8220;open for&#8221; loop involves a lot of method dispatching.</li><li>The <code>format(Date...)</code> in the JavaExtensions are not cheap if you care.</li></ul><p>BTW, there is a special directive names <code>`stopwatch</code> that can be used to log the time it takes a template to render data. </p><p><pre><br/>`stopwatch on<br/></pre> </p><p>A line like the following will be printed to the console:</p><p><pre><br/>[dummyTag] rendering time: 3<br/></pre></p><p>The unit of measurement is &#8220;ms&#8221;. </p><h2 id="MigratingfromPrecontrollerModeltoPostControllerModel">Migrating from Pre-controller Model to Post-Controller Model</h2><p>The future direction of Japid is the Post-Controller Model where the view layer is less coupled with the rest of the application. The benefits are:</p><p>1. Better performance. Reloading of controllers, models won&#8217;t lead to recompiling of all the Japidscript. And reloading of Japid script usually takes a blink to complete. <br/>2. Much nicer error reporting. Japid compilation errors are displayed in the nicely formatted error page provided by Play engine. The errors are mapped to the exact lines in the original Japid script. <br/>3. flexibility of manipulating the view layers such as the location of the template root, the internval to detect file system changes (or not at all) independent of Play&#8217;s mode (DEV or PROD). The API is provided by a method:</p><p><pre><br/>	/**<br/>	 * The <em>optional</em> initialization step in using the JapidRender.<br/>	 * <br/>	 * Users do not need to call this method to initialize this class. It takes<br/>	 * &#8220;japidroot&#8221; as the default template root, which is relative to the application<br/>	 * root. <br/>	 * <br/>	 * @param opMode<br/>	 *            the operational mode of Japid. When set to OpMode.prod, it&#8217;s<br/>	 *            assumed that all Java derivatives are already been generated<br/>	 *            and used directly. When set to OpMode.dev, and using<br/>	 *            none-static linking to using the renderer, file system changes<br/>	 *            are detected for every rendering request given the refresh<br/>	 *            interval is respected. New Java files are generated and<br/>	 *            compiled and new classes are loaded to serve the request.<br/>	 * @param templateRoot<br/>	 *            the root directory to contain the &#8220;japidviews&#8221; directory tree. It must<br/>	 *            be out of the &#8220;app&#8221; directory, or it will interfere with Play&#8217;s class<br/>	 *            loading. <br/>	 * @param refreshInterval<br/>	 *            the minimal time, in second, that must elapse before trying to<br/>	 *            detect any changes in the file system.<br/>	 */</p><p>JapidPlayRenderer.init(Mode opMode, String templateRoot, int refreshInterval)<br/></pre></p><p>Note: </p><p>1. Call this method in a bootstrap method. <br/>2. Using the API is optional. If it&#8217;s not used, Japid runs in the same <code>Mode</code> as the current Play app. The default root to host japidviews is named &#8220;japidroot&#8221; relative to the app root. The default change detecting interval is two seconds. </p><p>Migrating from Pre-Controller mode to Post-controller mode is easy:</p><p>1. Move the entire <code>japidview</code> directory to the &#8220;japidroot&#8221; folder (or a folder configured with the above function). <br/>2. Change all the controllers from extending from <code>JapidController</code> to <code>JapicControler2</code>.<br/>3. Change all mailers to extending from JapidMailer2. <br/>4. The _javatags folder in the japidviews folder is deprecated. Move all the static methods to utility classes in any of the app folder, such as the utils folder.  </p><p>That&#8217;ll be it. </p><p>Note: JapidController and JapidController2 might co-exist in the same application. Some part of the app might be using the old Japid integration model while others suing the new &#8220;indi&#8221; model. </p><p>::eof</p></body></html>